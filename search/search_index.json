{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentaci\u00f3n Elementos Programables II","text":""},{"location":"#nuestro-portafolio-de-actividades","title":"Nuestro Portafolio de Actividades","text":"<p>Introducci\u00f3n a la mec\u00e1tronica Departamento de Ciencias e Ingenier\u00edas | Universidad Iberoamericana Puebla, M\u00e9xico.</p> <p></p> <p>Karen Itzel Najera De Gante</p> <p>Ingenier\u00eda me\u00e1tronica | karen.najera@iberopuebla.mx</p> <p>Resumen: Soy estudiante de d\u00e9cimo semestre de Ingenier\u00eda Mecatr\u00f3nica, con formaci\u00f3n previa en Ingenier\u00eda Mec\u00e1nica. Mi pasi\u00f3n por los desaf\u00edos y la innovaci\u00f3n me llev\u00f3 a continuar mis estudios en una segunda carrera, con el objetivo de ampliar mis conocimientos y abrir mayores oportunidades en el campo laboral. Durante seis meses trabaj\u00e9 como analista en EDAG Test Lab M\u00e9xico, donde adquir\u00ed experiencia en pruebas y validaciones dentro del sector automotriz. Actualmente, sigo desarrollando mis habilidades en \u00e1reas multidisciplinarias, combinando mec\u00e1nica, electr\u00f3nica y automatizaci\u00f3n para enfrentar retos tecnol\u00f3gicos con una visi\u00f3n integral.</p> <p></p> <p>Arith Maldonado Zamudio</p> <p>Ingenier\u00eda me\u00e1tronica | arith.maldonado@iberopuebla.mx</p> <p>Resumen:</p> <p>Soy ingeniero mecatr\u00f3nico con inter\u00e9s en la electr\u00f3nica, el dise\u00f1o CAD y el desarrollo de soluciones tecnol\u00f3gicas. Me apasiona el dise\u00f1o y la innovaci\u00f3n, aplicando mis conocimientos para crear proyectos eficientes y funcionales en distintas \u00e1reas de la ingenier\u00eda.</p>"},{"location":"#_1","title":"Documentaci\u00f3n Elementos Programables II","text":""},{"location":"PR%C3%81CTICA%201/","title":"\ud83d\udcda Pr\u00e1ctica 1: Comunicaci\u00f3n Serial con ESP32-C6 en Arduino","text":""},{"location":"PR%C3%81CTICA%201/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Karen N\u00e1jera y Arith Maldonado </li> <li>Curso / Asignatura: Elementos programables II </li> <li>Fecha: 18/09/2025 </li> <li>Descripci\u00f3n breve:   En esta pr\u00e1ctica se implement\u00f3 un c\u00f3digo en Arduino IDE para establecer comunicaci\u00f3n serial con un ESP32-C6. Se explic\u00f3 el funcionamiento de los diferentes tipos de variables (<code>int</code>, <code>char</code>, <code>string</code>, <code>float</code>, <code>bool</code>) y la cantidad de datos que puede almacenar cada uno. Adem\u00e1s, se analizaron las diferencias entre los dos puertos de comunicaci\u00f3n del ESP32 (UART y USB nativo) y c\u00f3mo este recibe mensajes enviados desde el monitor serial.</li> </ul>"},{"location":"PR%C3%81CTICA%201/#2-objetivos","title":"2) Objetivos","text":"<ul> <li> <p>General: Comprender el funcionamiento b\u00e1sico de la comunicaci\u00f3n serial en el ESP32-C6 usando Arduino IDE. </p> </li> <li> <p>Espec\u00edficos: </p> </li> <li>Identificar y diferenciar los principales tipos de variables en Arduino.  </li> <li>Implementar un programa que permita recibir y mostrar mensajes en el monitor serial.  </li> <li>Analizar la diferencia entre el puerto UART (serial cl\u00e1sico) y el puerto USB nativo del ESP32.  </li> <li>Verificar la correcta recepci\u00f3n y env\u00edo de caracteres mediante pruebas pr\u00e1cticas.  </li> </ul>"},{"location":"PR%C3%81CTICA%201/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: </li> <li>Uso del ESP32-C6 como dispositivo de comunicaci\u00f3n serial.  </li> <li>Configuraci\u00f3n del baud rate en el monitor serial.  </li> <li>Recepci\u00f3n y env\u00edo de mensajes en el IDE de Arduino.  </li> <li> <p>Explicaci\u00f3n te\u00f3rica de los tipos de variables y su uso en la pr\u00e1ctica.  </p> </li> <li> <p>No incluye: </p> </li> <li>Conexi\u00f3n a sensores externos.  </li> <li>Programaci\u00f3n de librer\u00edas adicionales.  </li> <li>Uso de comunicaci\u00f3n inal\u00e1mbrica (Wi-Fi / Bluetooth).  </li> </ul>"},{"location":"PR%C3%81CTICA%201/#4-resultados","title":"4) Resultados","text":"<p>Durante la pr\u00e1ctica se logr\u00f3:  </p> <ul> <li>Recepci\u00f3n de datos seriales: El ESP32-C6 recibi\u00f3 correctamente mensajes enviados desde el monitor serial, aunque en un inicio aparecieron caracteres extra\u00f1os debido a un baud rate incorrecto. Ajustando la velocidad a 38400 baudios se solucion\u00f3 el problema.  </li> <li>Tipos de datos: </li> <li><code>int</code> \u2192 n\u00fameros enteros (16 bits).  </li> <li><code>char</code> \u2192 un car\u00e1cter (1 byte).  </li> <li><code>string</code> \u2192 cadena de caracteres (m\u00ednimo 16 bits, m\u00e1ximo variable).  </li> <li><code>float</code> \u2192 n\u00fameros con decimales (32 bits).  </li> <li><code>bool</code> \u2192 valores l\u00f3gicos (1 bit).  </li> <li>Puertos de comunicaci\u00f3n: </li> <li>UART (Universal Asynchronous Receiver-Transmitter): puerto serial tradicional, \u00fatil para depuraci\u00f3n o conexi\u00f3n con otros dispositivos.  </li> <li>USB nativo: permite programar directamente el microcontrolador y tambi\u00e9n enviar datos sin necesidad de un conversor externo.  </li> </ul> <p>C\u00f3digo Implementado</p> <pre><code>char msg;\n\nvoid setup() {\n  Serial.begin(38400);   // Inicializa comunicaci\u00f3n serial\n}\n\nvoid loop() {\n  if (Serial.available()) {   // Verifica si hay datos\n    msg = Serial.read();      // Lee el car\u00e1cter\n    Serial.print(msg);        // Lo reenv\u00eda al monitor\n  }\n}\n</code></pre>"},{"location":"PR%C3%81CTICA%201/#5-conclusiones","title":"5) Conclusiones","text":"<p>La pr\u00e1ctica permiti\u00f3 comprender y verificar el flujo b\u00e1sico de comunicaci\u00f3n serial en el ESP32-C6 usando Arduino IDE. Se implement\u00f3 un programa de eco que recibi\u00f3 y reenvi\u00f3 caracteres desde el monitor serial, lo que facilit\u00f3 la validaci\u00f3n del canal de datos y el diagn\u00f3stico de errores de configuraci\u00f3n, como el problema de lectura con caracteres extra\u00f1os que se resolvi\u00f3 al ajustar el baud rate a 38400. Adem\u00e1s, se reforz\u00f3 la diferenciaci\u00f3n de tipos de datos y su papel al manipular informaci\u00f3n a nivel de firmware, as\u00ed como la distinci\u00f3n funcional entre el puerto UART y el USB nativo, entendiendo en qu\u00e9 contextos conviene usar cada uno (depuraci\u00f3n/interop vs. programaci\u00f3n y transferencia directa).</p> <p>En conjunto, se cumplieron los objetivos propuestos: identificaci\u00f3n de tipos de variables, implementaci\u00f3n de un receptor de mensajes por serial y an\u00e1lisis de los puertos de comunicaci\u00f3n del ESP32-C6. Como trabajo futuro, se sugiere extender el ejemplo para procesar cadenas completas (comandos), confirmar par\u00e1metros de temporizaci\u00f3n seg\u00fan el entorno (OS/driver/IDE) y conectar perif\u00e9ricos que respondan a instrucciones recibidas por serial, consolidando as\u00ed una base s\u00f3lida para pr\u00e1cticas posteriores con protocolos m\u00e1s complejos.</p>"},{"location":"PR%C3%81CTICA%2010/","title":"\ud83d\udcdaPr\u00e1ctica 10 (P10): Procesamiento de Monedas con Operaciones Morfol\u00f3gicas","text":""},{"location":"PR%C3%81CTICA%2010/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Arith Maldonado</li> <li>Curso / Asignatura: Elementos programables II </li> <li>Fecha: 29/09/2025 </li> <li>Descripci\u00f3n breve: En esta pr\u00e1ctica se proces\u00f3 una imagen de un conjunto de monedas aplicando filtrado por color, umbralizaci\u00f3n y operaciones morfol\u00f3gicas (erosi\u00f3n y dilataci\u00f3n) para aislar los objetos de inter\u00e9s y retirar el fondo. Se identificaron contornos y se gener\u00f3 una m\u00e1scara para extraer \u00fanicamente las monedas detectadas mediante procesamiento digital de im\u00e1genes.</li> </ul>"},{"location":"PR%C3%81CTICA%2010/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Aplicar operaciones de morfolog\u00eda digital utilizando OpenCV para segmentar objetos en una imagen y aislar regiones mediante filtrado y contornos.</li> <li>Espec\u00edficos:</li> <li>Separar canales de color para descartar fondo no deseado.</li> <li>Aplicar umbral para resaltar bordes brillantes presentes en las monedas.</li> </ul>"},{"location":"PR%C3%81CTICA%2010/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye:  -Aplicaci\u00f3n de umbralizaci\u00f3n para resaltar los bordes brillantes de las monedas.</li> </ul> <p>-Uso de operaciones morfol\u00f3gicas para cierre de contornos.</p>"},{"location":"PR%C3%81CTICA%2010/#4-resultados","title":"4) Resultados","text":"<p>Al procesar la imagen, el filtrado por color permiti\u00f3 eliminar el fondo rojo sin afectar las monedas.</p> <p>La umbralizaci\u00f3n resalt\u00f3 las zonas brillantes correspondientes al aro met\u00e1lico de cada moneda.</p> <p>Las operaciones morfol\u00f3gicas de dilataci\u00f3n y erosi\u00f3n permitieron cerrar los contornos incompletos, reduciendo ruido y rellenando discontinuidades.</p> <p>La detecci\u00f3n de contornos permiti\u00f3 identificar cada moneda aislada, generando una m\u00e1scara que extrae \u00fanicamente las regiones v\u00e1lidas de la imagen.</p> <p>Los resultados muestran con claridad las monedas aisladas del resto de la imagen, confirmando el funcionamiento del procesamiento aplicado.</p>"},{"location":"PR%C3%81CTICA%2010/#6-archivos-adjuntos","title":"6) Archivos Adjuntos","text":"<pre><code>import cv2\nimport numpy as np\n# --- carga y resize ---\nimg = cv2.imread(\"images/Coins4.jpg\")\nh, w = img.shape[:2]\nMAX_W, MAX_H = 1080, 720\nscale = min(MAX_W / w, MAX_H / h, 1.0)\nif scale &lt; 1.0:\n    img = cv2.resize(img, (int(w*scale), int(h*scale)), interpolation=cv2.INTER_AREA)\ncv2.imshow(\"Original\", img)\n# --- canales para filtrar rojo (BGR) ---\nb = img[:, :, 0]\ng = img[:, :, 1]\nr = img[:, :, 2]\n# 1) FILTRO: quitar fondo rojo (en BGR)\nR_LOW_BG, G_HIGH_BG, B_HIGH_BG = 145, 110, 110\nmask_bg_red = cv2.bitwise_and(\n    cv2.inRange(r, R_LOW_BG, 255),\n    cv2.bitwise_and(cv2.inRange(g, 0, G_HIGH_BG),\n                    cv2.inRange(b, 0, B_HIGH_BG))\n)\nmask_not_red = cv2.bitwise_not(mask_bg_red)\n# 2) ESCALA DE GRISES\ngray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\ncv2.imshow(\"Gris\", gray)\n# 3) UMBRAL ALTO PARA QUEDARTE CON EL ARO (borde brillante)\nT_RING = 80\n_, ring = cv2.threshold(gray, T_RING, 255, cv2.THRESH_BINARY)\n# quitar cualquier aro que est\u00e9 sobre el tapete rojo\nring = cv2.bitwise_and(ring, mask_not_red)\ncv2.imshow(\"Aro en gris\", ring)\n# 4) MORFOLOG\u00cdA: cerrar el aro (mismas ops de clase)\nkernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))\nring_closed = cv2.dilate(ring, kernel, iterations=3)\nring_closed = cv2.erode (ring_closed, kernel, iterations=4)\ncv2.imshow(\"Aro cerrado\", ring_closed)\n# 5) CONTORNOS sobre el aro cerrado\ncontours, _ = cv2.findContours(ring_closed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\nimg_contours = img.copy()\ncv2.drawContours(img_contours, contours, -1, (0, 255, 0), 2)\ncv2.imshow(\"Monedas por contorno\", img_contours)\nmask_fill = np.zeros_like(gray)\ncv2.drawContours(mask_fill, contours, -1, 255, thickness=-1)  # -1 = rellenar\ncv2.imshow(\"Mascara rellena desde contorno\", mask_fill)\nresult = cv2.bitwise_and(img, img, mask=mask_fill)\ncv2.imshow(\"Monedas rellenas (desde contorno)\", result)\nwhile True:\n    if cv2.waitKey(20) == 27:\n        break\ncv2.destroyAllWindows()\n</code></pre>"},{"location":"PR%C3%81CTICA%2010/#5-conclusion","title":"5) Conclusi\u00f3n","text":"<p>La pr\u00e1ctica permiti\u00f3 comprobar que las operaciones morfol\u00f3gicas son fundamentales para la segmentaci\u00f3n efectiva de objetos en una escena, especialmente cuando existen irregularidades o ruido visual. El filtrado basado en canales de color permiti\u00f3 descartar el fondo sin afectar el objeto de inter\u00e9s, mientras que la umbralizaci\u00f3n destac\u00f3 caracter\u00edsticas relevantes como el brillo del aro. Se concluye que el procesamiento mediante erosi\u00f3n, dilataci\u00f3n y contornos es una t\u00e9cnica eficiente para extraer objetos de inter\u00e9s en im\u00e1genes, representando una base s\u00f3lida para futuras aplicaciones como conteo, clasificaci\u00f3n o inspecci\u00f3n autom\u00e1tica.</p>"},{"location":"PR%C3%81CTICA%202/","title":"\ud83d\udcda Pr\u00e1ctica 2: Control de LED NeoPixel con Arduino mediante comunicaci\u00f3n Serial.","text":""},{"location":"PR%C3%81CTICA%202/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Karen Najera y Arith Maldonado</li> <li>Curso / Asignatura: Elementos programables II </li> <li>Fecha: 20/08/2025 </li> <li>Descripci\u00f3n breve: En esta pr\u00e1ctica se implementa un programa en Arduino para controlar un LED NeoPixel a trav\u00e9s de comandos enviados por el monitor serial. El usuario puede enviar instrucciones como \u201cred\u201d, \u201cgreen\u201d o \u201cblue\u201d y el LED cambiar\u00e1 su color de acuerdo al mensaje recibido. La librer\u00eda Adafruit_NeoPixel permite el manejo de este tipo de LEDs direccionables de manera sencilla.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"PR%C3%81CTICA%202/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Comprender el funcionamiento b\u00e1sico de un LED NeoPixel y su control mediante comunicaci\u00f3n serial en Arduino.</li> <li>Espec\u00edficos:</li> <li>Configurar el puerto serial para recibir datos desde el monitor de Arduino ID</li> <li>Implementar la librer\u00eda Adafruit_NeoPixel para inicializar y controlar el LED.</li> <li>Programar condiciones que permitan el cambio de color del LED en funci\u00f3n del mensaje recibido.</li> </ul>"},{"location":"PR%C3%81CTICA%202/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: El c\u00f3digo desarrollado tiene como finalidad recibir comandos de texto a trav\u00e9s del puerto serial y traducirlos en cambios de color en un LED NeoPixel.</li> </ul> <p>Solo se controla un LED (NUMPIXELS = 1).</p> <p>-El usuario puede escribir \u201cred\u201d, \u201cgreen\u201d o \u201cblue\u201d en el monitor serial.</p> <p>-Cada mensaje recibido activa el LED con la intensidad y color definido.</p> <p>-Se incorpora un retardo de 1 segundo para visualizar claramente cada cambio.</p> <p>-La l\u00f3gica puede escalarse f\u00e1cilmente para m\u00e1s LEDs o m\u00e1s colores..</p>"},{"location":"PR%C3%81CTICA%202/#4-resultados","title":"4) Resultados","text":"<p>Al realizar la pr\u00e1ctica se comprob\u00f3 que el sistema respondi\u00f3 de manera adecuada a los comandos enviados desde el monitor serial. Cada vez que se ingres\u00f3 la palabra \u201cred\u201d, el LED NeoPixel se ilumin\u00f3 en color rojo con la intensidad programada; al escribir \u201cgreen\u201d, el LED cambi\u00f3 correctamente a color verde; y al introducir \u201cblue\u201d, se encendi\u00f3 en color azul. C\u00f3digo El retardo de un segundo facilit\u00f3 la observaci\u00f3n de cada cambio de color antes de recibir un nuevo comando, lo que permiti\u00f3 validar visualmente el funcionamiento del programa. Adem\u00e1s, se constat\u00f3 que el uso del car\u00e1cter coma (,) como delimitador en la lectura de cadenas evit\u00f3 errores de interpretaci\u00f3n en los mensajes.</p> <p></p> <p>En general, el comportamiento del LED fue estable, sin presentar fallos de comunicaci\u00f3n ni bloqueos durante las pruebas, lo cual confirma la correcta implementaci\u00f3n de la librer\u00eda y de la l\u00f3gica de control.</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"PR%C3%81CTICA%202/#6-codigo","title":"6) C\u00f3digo","text":"<pre><code>// NeoPixel Ring simple sketch (c) 2013 Shae Erisson\n// Released under the GPLv3 license to match the rest of the\n// Adafruit NeoPixel library\n\n#include &lt;Adafruit_NeoPixel.h&gt;\n#ifdef __AVR__\n #include &lt;avr/power.h&gt; // Required for 16 MHz Adafruit Trinket\n#endif\n\n// Which pin on the Arduino is connected to the NeoPixels?\n#define PIN 8    // On Trinket or Gemma, suggest changing this to 1\n\n// How many NeoPixels are attached to the Arduino?\n#define NUMPIXELS 1 // Popular NeoPixel ring size\n\n// When setting up the NeoPixel library, we tell it how many pixels,\n// and which pin to use to send signals. Note that for older NeoPixel\n// strips you might need to change the third parameter -- see the\n// strandtest example for more information on possible values.\nAdafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);\n\n#define DELAYVAL 500 // Time (in milliseconds) to pause between pixels\n\nString msj=\"\";\n\nvoid setup() {\n   Serial.begin(115200);//Inicia Serial a 115200 bauds o 115200 char/s\n  pixels.begin(); // INITIALIZE NeoPixel strip object (REQUIRED)\n}\n\nvoid loop() {\n\n   if(Serial.available()&gt;0){ //Entrar al if solo si se recibe algo por el serial\n    msj = Serial.readStringUntil(',');//Ciclo hasta leer el char marcado\n    Serial.println(msj); //Imprime el comando recibido\n  }\n\n  if(msj==\"red\")\n  {\n    pixels.clear(); // Set all pixel colors to 'off'\n    pixels.setPixelColor(0, pixels.Color(150, 0, 0));\n    pixels.show();   // Send the updated pixel colors to the hardware.\n    delay (1000);\n  }\n\n  else if(msj==\"green\"){\n    pixels.clear(); // Set all pixel colors to 'off'\n    pixels.setPixelColor(0, pixels.Color(0, 150, 0));\n    pixels.show();\n    delay (1000);\n  }\n  else if(msj==\"blue\"){\n    pixels.clear(); // Set all pixel colors to 'off'\n    pixels.setPixelColor(0, pixels.Color(0, 0, 150));\n    pixels.show();\n    delay (1000);\n  }\n\n\n\n}\n</code></pre>"},{"location":"PR%C3%81CTICA%202/#5-conclusion","title":"5) Conclusi\u00f3n","text":"<p>Con esta pr\u00e1ctica se demostr\u00f3 el uso b\u00e1sico de la librer\u00eda Adafruit_NeoPixel para controlar LEDs direccionables mediante comunicaci\u00f3n serial. El programa permite al usuario interactuar directamente con el hardware enviando comandos simples desde el monitor serial, logrando as\u00ed un cambio de color en el LED. Esta l\u00f3gica se puede ampliar a tiras LED m\u00e1s grandes y a una gama m\u00e1s amplia de colores, lo cual representa una aplicaci\u00f3n fundamental en proyectos de iluminaci\u00f3n decorativa, rob\u00f3tica y se\u00f1alizaci\u00f3n.</p>"},{"location":"PR%C3%81CTICA%203/","title":"\ud83d\udcda Pr\u00e1ctica 3: Control de LED NeoPixel por comandos R,G,B (ESP32-C6 + Arduino IDE)","text":""},{"location":"PR%C3%81CTICA%203/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Karen N\u00e1jera y Arith Maldonado </li> <li>Curso / Asignatura: Elementos programables II </li> <li>Fecha: 18/09/2025 </li> <li>Descripci\u00f3n breve:   En esta pr\u00e1ctica se implement\u00f3 un programa en Arduino IDE para controlar un NeoPixel conectado a un ESP32-C6 recibiendo comandos por Serial en el formato <code>R&lt;r&gt;,G&lt;g&gt;,B&lt;b&gt;</code> (0\u2013255). Se reforz\u00f3 el manejo de tipos de variables, el uso de la librer\u00eda Adafruit_NeoPixel y la diferencia pr\u00e1ctica entre UART y USB nativo.</li> </ul> <p>Tip: Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"PR%C3%81CTICA%203/#2-objetivos","title":"2) Objetivos","text":"<ul> <li> <p>General: Comprender y aplicar la comunicaci\u00f3n serial en el ESP32-C6 para controlar un LED NeoPixel mediante comandos <code>R,G,B</code>.</p> </li> <li> <p>Espec\u00edficos: </p> </li> <li>Configurar el puerto Serial y verificar su velocidad.  </li> <li>Parsear un comando de texto con tres canales (R, G, B).  </li> <li>Limitar cada canal al rango v\u00e1lido 0\u2013255 y actualizar el color del NeoPixel.  </li> <li>Comparar el uso de USB nativo frente a UART para depuraci\u00f3n y pruebas.</li> </ul>"},{"location":"PR%C3%81CTICA%203/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: </li> <li>Control de 1 LED NeoPixel (<code>NUMPIXELS = 1</code>).  </li> <li>Recepci\u00f3n de comandos por Monitor Serial (<code>R&lt;r&gt;,G&lt;g&gt;,B&lt;b&gt;</code>).  </li> <li> <p>Ajuste de baud rate y verificaci\u00f3n de eco.</p> </li> <li> <p>No incluye: </p> </li> <li>Conexi\u00f3n a sensores externos.  </li> <li>Uso de Wi-Fi / Bluetooth.  </li> <li>Efectos avanzados o animaciones en tiras LED.</li> </ul>"},{"location":"PR%C3%81CTICA%203/#4-resultados","title":"4) Resultados","text":"<ul> <li>Recepci\u00f3n de comandos seriales y aplicaci\u00f3n inmediata del color en el NeoPixel.  </li> <li>Velocidad usada: 115200 baudios (coincidente entre <code>Serial.begin</code> y Monitor Serial).  </li> <li>Validaci\u00f3n de entrada: cada canal se restringe con <code>constrain(...)</code> a 0\u2013255.  </li> <li>Ejemplos probados: <code>R120,G110,B10</code>, <code>R255,G0,B0</code>, <code>R0,G0,B255</code>.</li> </ul>"},{"location":"PR%C3%81CTICA%203/#5-protocolo-de-comandos-y-pruebas","title":"5) Protocolo de comandos y pruebas","text":"<ul> <li>Formato: <code>R&lt;r&gt;,G&lt;g&gt;,B&lt;b&gt;</code> </li> <li>Rango: <code>0\u2013255</code> por canal.  </li> <li>Delimitaci\u00f3n: valores separados por coma y finalizados con Enter (<code>\\n</code>).  </li> </ul> <p>Pruebas sugeridas - <code>R255,G0,B0</code> (rojo) - <code>R0,G255,B0</code> (verde) - <code>R0,G0,B255</code> (azul) - <code>R255,G191,B0</code> (\u00e1mbar) - <code>R10,G10,B10</code> (atenuado)</p>"},{"location":"PR%C3%81CTICA%203/#6-codigo-implementado","title":"6) C\u00f3digo Implementado","text":"<pre><code>#include &lt;Adafruit_NeoPixel.h&gt;\n#ifdef __AVR__\n  #include &lt;avr/power.h&gt;\n#endif\n\n#define PIN 8\n#define NUMPIXELS 1\n\nAdafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);\n\nString cmd = \"\";\nint r = 0, g = 0, b = 0;\n\nvoid setup() {\n  Serial.begin(115200);\n  pixels.begin();\n}\n\nvoid loop() {\n  if (Serial.available() &gt; 0) {\n    cmd = Serial.readStringUntil('\\n');\n    Serial.println(\"Msj recibido: \" + cmd);\n\n    int pos1 = cmd.indexOf(',');      \n    int pos2 = cmd.indexOf(',', pos1 + 1);\n\n    String rPart = cmd.substring(0, pos1);                \n    String gPart = cmd.substring(pos1 + 1, pos2);        \n    String bPart = cmd.substring(pos2 + 1);              \n\n    // Extrae el n\u00famero despu\u00e9s de la letra (R/G/B) y limita a 0-255\n    r = constrain(rPart.substring(1).toInt(), 0, 255);\n    g = constrain(gPart.substring(1).toInt(), 0, 255);\n    b = constrain(bPart.substring(1).toInt(), 0, 255);\n\n    pixels.clear();\n    pixels.setPixelColor(0, pixels.Color(r, g, b));\n    pixels.show();\n  }\n}\n</code></pre>"},{"location":"PR%C3%81CTICA%203/#7-conclusiones","title":"7) Conclusiones","text":"<p>La pr\u00e1ctica consolid\u00f3 el control determinista de un NeoPixel v\u00eda comandos seriales R,G,B en el ESP32-C6. Se valid\u00f3 el parseo de texto con separaci\u00f3n por comas y el mapeo de cada canal a su rango permitido (0\u2013255), reflej\u00e1ndose de inmediato en el LED mediante Adafruit_NeoPixel. La sincron\u00eda de baudios (115200) entre Serial.begin y el Monitor Serial evit\u00f3 errores de lectura, y la comparaci\u00f3n entre USB nativo y UART aclar\u00f3 escenarios de uso (programaci\u00f3n/depuraci\u00f3n directa vs. interoperabilidad con otros dispositivos). En suma, se cumplieron los objetivos: configuraci\u00f3n del puerto, interpretaci\u00f3n de comandos, limitaci\u00f3n de rango y actualizaci\u00f3n correcta del color.</p> <p>Como mejora futura, se recomienda:</p> <p>Robustecer el protocolo: tolerar espacios y min\u00fasculas, manejar \\r\\n, validar formato (faltas de coma o letras) y enviar ACK/ERROR al host.</p> <p>Experiencia visual: agregar brillo global y correcci\u00f3n gamma, y extender a m\u00e1s p\u00edxeles/animaciones manteniendo tiempos no bloqueantes.</p> <p>Fiabilidad el\u00e9ctrica: asegurar alimentaci\u00f3n estable del LED (condensador de 100\u20131000 \u00b5F en 5 V) y cuidar la compatibilidad de niveles de datos (3.3 V suele funcionar, pero considerar un level shifter en tiras largas).</p> <p>Estas extensiones convertir\u00e1n el ejercicio en una base s\u00f3lida para protocolos m\u00e1s ricos (p. ej., comandos con brillo, efectos o m\u00faltiples LEDs) y para integrar perif\u00e9ricos que reaccionen a instrucciones seriales en tiempo real.</p>"},{"location":"PR%C3%81CTICA%204/","title":"\ud83d\udcda Pr\u00e1ctica 4: Lectura de Aceler\u00f3metro MPU6050 con Arduino","text":""},{"location":"PR%C3%81CTICA%204/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Karen Najera y Arith Maldonado</li> <li>Curso / Asignatura: Elementos programables II </li> <li>Fecha: 01/09/2025 </li> <li>Descripci\u00f3n breve: En esta pr\u00e1ctica se implementa un programa en Arduino para leer datos de un aceler\u00f3metro y giroscopio MPU6050 mediante comunicaci\u00f3n I2C. El sistema recoge informaci\u00f3n de aceleraci\u00f3n en tres ejes (X, Y, Z), velocidades angulares (giroscopio) y temperatura interna del sensor, mostrando los valores por el monitor serial.</li> </ul>"},{"location":"PR%C3%81CTICA%204/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Comprender el funcionamiento b\u00e1sico del sensor MPU6050 y su lectura mediante la comunicaci\u00f3n I2C en Arduino..</li> <li>Espec\u00edficos:</li> <li>Inicializar correctamente el sensor MPU6050 utilizando la interfaz I2C.</li> <li>Leer y convertir los datos de aceleraci\u00f3n, temperatura y giroscopio</li> <li>Mostrar los valores en el monitor serial para su an\u00e1lisis y visualizaci\u00f3n.</li> </ul>"},{"location":"PR%C3%81CTICA%204/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: a pr\u00e1ctica se enfoca en la lectura y visualizaci\u00f3n de los datos del sensor MPU6050, el cual proporciona informaci\u00f3n \u00fatil de aceleraci\u00f3n, temperatura y velocidad angular.</li> </ul> <p>-Los datos se obtienen usando comunicaci\u00f3n I2C a trav\u00e9s de la librer\u00eda Wire.</p> <p>-La salida de datos es continua y se presenta en el monitor serial cada segundo.</p> <p>-No se utiliza ninguna librer\u00eda externa espec\u00edfica para MPU6050, se accede directamente a los registros del sensor.</p> <p>-Los valores obtenidos son procesados para mostrar aceleraci\u00f3n en \"g\", temperatura en \u00b0C y giroscopio en \u00b0/s.</p> <p>-_Los valores obtenidos son procesados para mostrar:</p> <p><code>Aceleraci\u00f3n en g</code> <code>Temperatura en \u00b0C</code> <code>Giroscopio en \u00b0/s</code>_</p>"},{"location":"PR%C3%81CTICA%204/#4-resultados","title":"4) Resultados","text":"<p>Para esta pr\u00e1ctica, se consult\u00f3 la hoja de datos del MPU6050, donde se especifican las direcciones de los registros internos. Cada tipo de dato se encuentra en registros consecutivos:</p> Tipo de Dato Direcci\u00f3n Base Bytes le\u00eddos Descripci\u00f3n Aceler\u00f3metro <code>0x3B</code> 6 bytes X (2), Y (2), Z (2) Temperatura <code>0x41</code> 2 bytes Solo 1 dato (valor de 16 bits) Giroscopio <code>0x43</code> 6 bytes X (2), Y (2), Z (2) <p>Al ejecutar el programa cargado en el Arduino, se pudo observar que la lectura de datos del sensor MPU6050 se realiz\u00f3 de manera satisfactoria. Los valores de aceleraci\u00f3n en los ejes X, Y y Z respondieron correctamente al mover f\u00edsicamente el sensor, mostrando cambios en tiempo real en el monitor serial. Esto confirm\u00f3 que la configuraci\u00f3n de los registros internos del sensor y la escala aplicada a los datos fue adecuada, permitiendo representar la aceleraci\u00f3n en unidades de \"g\".</p> <p>El programa utiliza la librer\u00eda Wire.h para establecer la comunicaci\u00f3n I2C entre el Arduino y el sensor MPU6050. Esta comunicaci\u00f3n requiere una direcci\u00f3n del dispositivo, en este caso 0x69, que corresponde al sensor. Cada tipo de dato (aceleraci\u00f3n, giroscopio, temperatura) se encuentra en una posici\u00f3n espec\u00edfica de memoria interna del sensor, llamada registro. El programa accede a esos registros para leer la informaci\u00f3n.Primero, en el setup(), se inicializa la comunicaci\u00f3n I2C (Wire.begin()) y el monitor serial (Serial.begin(115200)). Luego, se despierta el sensor escribiendo 0x00 en el registro de encendido 0x6B.El programa Lee la aceleraci\u00f3n, luego la temperatura y por ultimo la velocidad del giroscopio, ajustando la escala a cada dato.</p> <p></p> <p>En resumen, la pr\u00e1ctica permiti\u00f3 obtener con \u00e9xito los tres tipos de datos proporcionados por el sensor: aceleraci\u00f3n, velocidad angular y temperatura, validando tanto la lectura directa de registros como el procesamiento correcto de los datos. Adem\u00e1s, se verific\u00f3 la importancia de interpretar los datos como enteros con signo y de seguir la documentaci\u00f3n oficial (datasheet) para aplicar correctamente las f\u00f3rmulas y las direcciones de memoria.</p>"},{"location":"PR%C3%81CTICA%204/#6-archivos-adjuntos","title":"6) Archivos Adjuntos","text":"<pre><code>#include &lt;Wire.h&gt;\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n\n#define MPU_ADDR 0x69\n#define reg_accelx 0x3b\n#define reg_accely 0x3d\n#define reg_accelz 0x3f\n#define reg_temp1 0x41\n#define reg_girox 0x43\n#define reg_giroy 0x45\n#define reg_giroz 0x47\nint x_1=0;\nint x_2=0;\nint y_1=0;\nint y_2=0;\nint z_1=0;\nint z_2=0;\nint girox_1=0;\nint girox_2=0;\nint giroy_1=0;\nint giroy_2=0;\nint giroz_1=0;\nint giroz_2=0;\nint temp_1=0;\nint temp_2=0;\n\nvoid setup() {\n  // put your setup code here, to run once:\n  Wire.begin();\n  Serial.begin(115200);\n  Wire.beginTransmission(MPU_ADDR);\n  Wire.write(0x6b);\n  Wire.write(0x00);\n  Wire.endTransmission(true);\n\n\n\n}\n\nvoid loop() {\n  Wire.beginTransmission(MPU_ADDR); //Start + send address devide\n  Wire.write(reg_accelx); //Write register\n\n  Wire.endTransmission(false); //Restart\n  Wire.requestFrom(MPU_ADDR,6,true); // aqui se pone el numero de datos que queremos (6)\n  if(Wire.available()){\n    x_1 = Wire.read();\n    x_2 = Wire.read();\n    y_1 = Wire.read();\n    y_2 = Wire.read();\n    z_1 = Wire.read();\n    z_2 = Wire.read();\n  }\n  else{\n    Serial.println(\"Error\");\n  }\n  Wire.endTransmission(true); //Stop\n\n  Wire.beginTransmission(MPU_ADDR); //Start + send address devide\n  Wire.write(reg_temp1); //Write register\n\n  Wire.endTransmission(false); //Restart\n  Wire.requestFrom(MPU_ADDR,2,true); // aqui se pone el numero de datos que queremos (6)\n  if(Wire.available()){\n    temp_1 = Wire.read();\n    temp_2 = Wire.read();\n\n  }\n  else{\n    Serial.println(\"Error\");\n  }\n  Wire.endTransmission(true); //Stop\n\nWire.beginTransmission(MPU_ADDR); //Start + send address devide\n  Wire.write(reg_girox); //Write register\n\n  Wire.endTransmission(false); //Restart\n  Wire.requestFrom(MPU_ADDR,6,true); // aqui se pone el numero de datos que queremos (6)\n  if(Wire.available()){\n    girox_1 = Wire.read();\n    girox_2 = Wire.read();\n    giroy_1 = Wire.read();\n    giroy_2 = Wire.read();\n    giroz_1 = Wire.read();\n    giroz_2 = Wire.read();\n  }\n  else{\n    Serial.println(\"Error\");\n  }\n  Wire.endTransmission(true); //Stop\n\n\n  int completo = (x_1 &lt;&lt;8) | x_2;\n  float aceleracion_x = (float)completo / 16384.0;\n  Serial.print(\"ACX:\");\n  Serial.println(aceleracion_x);\n\n\n\n  int16_t completo1 = (y_1 &lt;&lt;8) | y_2;\n  float aceleracion_y = (float)completo1 / 16384.0;\n  Serial.print(\"ACY:\");\n  Serial.println(aceleracion_y);\n\n  int16_t completo2 = (z_1 &lt;&lt;8) | z_2;\n  float aceleracion_z = (float)completo2 / 16384.0;\n  Serial.print(\"ACZ:\");\n  Serial.println(aceleracion_z);\n\n  int16_t completo4 = (girox_1 &lt;&lt;8) | girox_2;\n  float giro_x = (float)completo4 / 131.0;\n  Serial.print(\"GIROX:\");\n  Serial.println(giro_x);\n\n  int16_t completo5 = (giroy_1 &lt;&lt;8) | giroy_2;\n  float giro_y = (float)completo5 / 131.0;\n  Serial.print(\"GIROY:\");\n  Serial.println(giro_y);\n\n  int16_t completo6 = (giroz_1 &lt;&lt;8) | giroz_2;\n  float giro_z = (float)completo6 / 131.0;\n  Serial.print(\"GIROZ:\");\n  Serial.println(giro_z);\n\n  int16_t completo3 = (temp_1 &lt;&lt;8) | temp_2;\n  float temperatura_1 = (float)completo3 / 340.0 + 36.53;\n  Serial.print(\"TEMP:\");\n  Serial.println(temperatura_1);\n\n\n  delay (1000);\n}\n</code></pre>"},{"location":"PR%C3%81CTICA%204/#5-conclusion","title":"5) Conclusi\u00f3n","text":"<p>_Esta pr\u00e1ctica permiti\u00f3 poner en funcionamiento un sensor MPU6050 sin el uso de librer\u00edas externas espec\u00edficas, lo cual facilita una comprensi\u00f3n m\u00e1s profunda del protocolo de comunicaci\u00f3n I2C y de la estructura de datos del sensor. La obtenci\u00f3n de valores crudos y su posterior escalado muestran c\u00f3mo se puede traducir informaci\u00f3n binaria en datos f\u00edsicos \u00fatiles.Los conocimientos adquiridos pueden aplicarse en proyectos que involucren navegaci\u00f3n, rob\u00f3tica, drones, estabilizadores, entre otros. La pr\u00e1ctica tambi\u00e9n sienta las bases para integrar m\u00faltiples sensores y realizar an\u00e1lisis de movimiento m\u00e1s avanzados.</p>"},{"location":"PR%C3%81CTICA%205/","title":"\ud83d\udcda Pr\u00e1ctica 5: ESP32-C6 como Beacon (BLE Advertising)","text":""},{"location":"PR%C3%81CTICA%205/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Karen N\u00e1jera y Arith Maldonado </li> <li>Curso / Asignatura: Elementos programables II </li> <li>Fecha: 18/09/2025 </li> <li>Descripci\u00f3n breve:   En esta pr\u00e1ctica configuramos el ESP32-C6 como un dispositivo BLE que anuncia su presencia (Advertising). Se crea un servidor BLE, un servicio con UUID propio y se inicia el anuncio para que pueda ser detectado por apps como nRF Connect o LightBlue.</li> </ul>"},{"location":"PR%C3%81CTICA%205/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Inicializar el stack BLE del ESP32-C6 con un nombre de dispositivo.</li> <li>Crear un servidor BLE, un servicio y una caracter\u00edstica b\u00e1sica.</li> <li>Iniciar y comprobar el Advertising desde el Monitor Serial y el tel\u00e9fono.</li> </ul>"},{"location":"PR%C3%81CTICA%205/#3-materiales","title":"3) Materiales","text":"<ul> <li>ESP32-C6 Dev Module  </li> <li>Cable USB  </li> <li>Arduino IDE (core ESP32 instalado)  </li> <li>App BLE en smartphone (p. ej., nRF Connect / LightBlue)</li> </ul>"},{"location":"PR%C3%81CTICA%205/#4-codigo","title":"4) C\u00f3digo","text":"<pre><code>#include &lt;BLEDevice.h&gt;\n#include &lt;BLEUtils.h&gt;\n#include &lt;BLEServer.h&gt;\n\n// ====== Configuraci\u00f3n ======\nstatic const char* DEVICE_NAME = \"AKDevice\";  // Nombre que ver\u00e1s en el escaneo\n#define SERVICE_UUID        \"12345678-1234-1234-1234-1234567890ab\"\n#define CHARACTERISTIC_UUID \"abcd1234-5678-90ab-cdef-1234567890ab\"\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(100);\n\n  // 1) Inicializa BLE con nombre\n  BLEDevice::init(DEVICE_NAME);\n\n  // 2) Crea servidor y servicio\n  BLEServer*      pServer  = BLEDevice::createServer();\n  BLEService*     pService = pServer-&gt;createService(SERVICE_UUID);\n\n  // 3) Caracter\u00edstica de ejemplo (Lectura/Escritura)\n  BLECharacteristic* pCharacteristic = pService-&gt;createCharacteristic(\n      CHARACTERISTIC_UUID,\n      BLECharacteristic::PROPERTY_READ   |\n      BLECharacteristic::PROPERTY_WRITE\n  );\n  pCharacteristic-&gt;setValue(\"Hola BLE\");\n\n  // 4) Inicia el servicio\n  pService-&gt;start();\n\n  // 5) Configura el advertising\n  BLEAdvertising* pAdvertising = BLEDevice::getAdvertising();\n  pAdvertising-&gt;addServiceUUID(SERVICE_UUID);   // Anuncia el UUID del servicio\n  pAdvertising-&gt;setScanResponse(true);          // Info extra en la respuesta de escaneo\n  pAdvertising-&gt;setMinPreferred(0x06);          // Par\u00e1metros recomendados\n  pAdvertising-&gt;setMinPreferred(0x12);\n\n  // 6) Inicia advertising\n  BLEDevice::startAdvertising();\n  Serial.println(\"BLE Advertising started\");\n}\n\nvoid loop() {\n  // Nada en el loop; el anuncio corre en segundo plano\n  delay(1000);\n}\n</code></pre>"},{"location":"PR%C3%81CTICA%205/#5-conclusiones","title":"5) Conclusiones","text":"<p>La pr\u00e1ctica demostr\u00f3 el uso b\u00e1sico de BLE en el ESP32-C6 configur\u00e1ndolo como beacon publicitario: se inicializ\u00f3 el dispositivo con nombre propio, se cre\u00f3 un servidor GATT con servicio y caracter\u00edstica y se inici\u00f3 el advertising incluyendo el UUID del servicio y scan response, lo que permiti\u00f3 descubrir y verificar el dispositivo desde apps m\u00f3viles (p. ej., nRF Connect / LightBlue). Con ello, se cumpli\u00f3 el objetivo de exponer presencia y metadatos por BLE y confirmar, desde el Monitor Serial y el smartphone, que el anuncio permanece activo en segundo plano.</p> <p>Como mejoras futuras se sugiere:</p> <p>Como mejoras futuras se sugiere:</p> <ul> <li>Ajustar par\u00e1metros de advertising (intervalo, potencia TX) para balancear alcance vs. consumo y observar el impacto en RSSI.</li> <li>Agregar datos en el payload (Manufacturer Data o Service Data) o adoptar formatos est\u00e1ndar como iBeacon/Eddystone cuando aplique.</li> <li>Gestionar estados: detener/relanzar advertising al conectar, y agregar callbacks del servidor para eventos (onConnect/onDisconnect).</li> <li>Seguridad y privacidad: habilitar MAC aleatoria, definir propiedades/permiso de la caracter\u00edstica (read/write/notify) y, si procede, emparejamiento.</li> <li>Escalabilidad: m\u00faltiples caracter\u00edsticas/servicios y notificaciones (notify/indicate) para aplicaciones interactivas m\u00e1s all\u00e1 del simple anuncio.</li> </ul>"},{"location":"PR%C3%81CTICA%206/","title":"\ud83d\udcda Pr\u00e1ctica 6: ESP32-C6 como Beacon (BLE Advertising)","text":""},{"location":"PR%C3%81CTICA%206/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Karen N\u00e1jera y Arith Maldonado </li> <li>Curso / Asignatura: Elementos programables II </li> <li>Fecha: 18/09/2025 </li> <li>Descripci\u00f3n breve:   En esta pr\u00e1ctica configuramos el ESP32-C6 como un dispositivo BLE que anuncia su presencia (Advertising). Se crea un servidor BLE, un servicio con UUID propio y se inicia el anuncio para que pueda ser detectado por apps como nRF Connect o LightBlue.</li> </ul>"},{"location":"PR%C3%81CTICA%206/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Inicializar el stack BLE del ESP32-C6 con un nombre de dispositivo.</li> <li>Crear un servidor BLE, un servicio y una caracter\u00edstica b\u00e1sica.</li> <li>Iniciar y comprobar el Advertising desde el Monitor Serial y el tel\u00e9fono.</li> </ul>"},{"location":"PR%C3%81CTICA%206/#3-materiales","title":"3) Materiales","text":"<ul> <li>ESP32-C6 Dev Module  </li> <li>Cable USB  </li> <li>Arduino IDE (core ESP32 instalado)  </li> <li>App BLE en smartphone (p. ej., nRF Connect / LightBlue)</li> </ul>"},{"location":"PR%C3%81CTICA%206/#4-codigo","title":"4) C\u00f3digo","text":"<pre><code>#include &lt;BLEDevice.h&gt;\n#include &lt;BLEUtils.h&gt;\n#include &lt;BLEServer.h&gt;\n\n// ====== Configuraci\u00f3n ======\nstatic const char* DEVICE_NAME = \"AKDevice\";  // Nombre que ver\u00e1s en el escaneo\n#define SERVICE_UUID        \"12345678-1234-1234-1234-1234567890ab\"\n#define CHARACTERISTIC_UUID \"abcd1234-5678-90ab-cdef-1234567890ab\"\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(100);\n\n  // 1) Inicializa BLE con nombre\n  BLEDevice::init(DEVICE_NAME);\n\n  // 2) Crea servidor y servicio\n  BLEServer*      pServer  = BLEDevice::createServer();\n  BLEService*     pService = pServer-&gt;createService(SERVICE_UUID);\n\n  // 3) Caracter\u00edstica de ejemplo (Lectura/Escritura)\n  BLECharacteristic* pCharacteristic = pService-&gt;createCharacteristic(\n      CHARACTERISTIC_UUID,\n      BLECharacteristic::PROPERTY_READ   |\n      BLECharacteristic::PROPERTY_WRITE\n  );\n  pCharacteristic-&gt;setValue(\"Hola BLE\");\n\n  // 4) Inicia el servicio\n  pService-&gt;start();\n\n  // 5) Configura el advertising\n  BLEAdvertising* pAdvertising = BLEDevice::getAdvertising();\n  pAdvertising-&gt;addServiceUUID(SERVICE_UUID);   // Anuncia el UUID del servicio\n  pAdvertising-&gt;setScanResponse(true);          // Info extra en la respuesta de escaneo\n  pAdvertising-&gt;setMinPreferred(0x06);          // Par\u00e1metros recomendados\n  pAdvertising-&gt;setMinPreferred(0x12);\n\n  // 6) Inicia advertising\n  BLEDevice::startAdvertising();\n  Serial.println(\"BLE Advertising started\");\n}\n\nvoid loop() {\n  // Nada en el loop; el anuncio corre en segundo plano\n  delay(1000);\n}\n</code></pre>"},{"location":"PR%C3%81CTICA%206/#5-conclusiones","title":"5) Conclusiones","text":"<p>La pr\u00e1ctica demostr\u00f3 el uso b\u00e1sico de BLE en el ESP32-C6 configur\u00e1ndolo como beacon publicitario: se inicializ\u00f3 el dispositivo con nombre propio, se cre\u00f3 un servidor GATT con servicio y caracter\u00edstica y se inici\u00f3 el advertising incluyendo el UUID del servicio y scan response, lo que permiti\u00f3 descubrir y verificar el dispositivo desde apps m\u00f3viles (p. ej., nRF Connect / LightBlue). Con ello, se cumpli\u00f3 el objetivo de exponer presencia y metadatos por BLE y confirmar, desde el Monitor Serial y el smartphone, que el anuncio permanece activo en segundo plano.</p> <p>Como mejoras futuras se sugiere:</p> <p>Como mejoras futuras se sugiere:</p> <ul> <li>Ajustar par\u00e1metros de advertising (intervalo, potencia TX) para balancear alcance vs. consumo y observar el impacto en RSSI.</li> <li>Agregar datos en el payload (Manufacturer Data o Service Data) o adoptar formatos est\u00e1ndar como iBeacon/Eddystone cuando aplique.</li> <li>Gestionar estados: detener/relanzar advertising al conectar, y agregar callbacks del servidor para eventos (onConnect/onDisconnect).</li> <li>Seguridad y privacidad: habilitar MAC aleatoria, definir propiedades/permiso de la caracter\u00edstica (read/write/notify) y, si procede, emparejamiento.</li> <li>Escalabilidad: m\u00faltiples caracter\u00edsticas/servicios y notificaciones (notify/indicate) para aplicaciones interactivas m\u00e1s all\u00e1 del simple anuncio.</li> </ul>"},{"location":"PR%C3%81CTICA%207/","title":"\ud83d\udcda Pr\u00e1ctica 7: Control de LEDs con ESP32 mediante Servidor Web","text":""},{"location":"PR%C3%81CTICA%207/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Karen Najera y Arith Maldonado</li> <li>Curso / Asignatura: Elementos programables II </li> <li>Fecha: 22/09/2025 </li> <li>Descripci\u00f3n breve: En esta pr\u00e1ctica se configur\u00f3 un ESP32 como servidor web para controlar tres LEDs a trav\u00e9s de una red WiFi local. Se implement\u00f3 una interfaz web sencilla que permite encender y apagar un LED principal mediante un bot\u00f3n en la p\u00e1gina, mientras que los otros LEDs pueden controlarse utilizando diferentes rutas URL. El sistema demuestra c\u00f3mo integrar redes inal\u00e1mbricas con hardware f\u00edsico en proyectos de IoT.</li> </ul>"},{"location":"PR%C3%81CTICA%207/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Comprender el funcionamiento de un servidor web en el ESP32 y su aplicaci\u00f3n en el control remoto de dispositivos electr\u00f3nicos.</li> <li>Espec\u00edficos:</li> <li>Configurar el ESP32 para conectarse a una red WiFi.</li> <li>Implementar un servidor web que responda a diferentes rutas (URLs).</li> <li>Encender y apagar LEDs mediante botones en una p\u00e1gina web y mediante acceso directo a URL.</li> </ul>"},{"location":"PR%C3%81CTICA%207/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye:  -Control de tres LEDs independientes a trav\u00e9s de rutas espec\u00edficas en el servidor.</li> </ul> <p>-Prueba del sistema accediendo desde un navegador web en la misma red.</p> <p>-Conexi\u00f3n del ESP32 a una red WiFi local.</p> <p>-No se implementa autenticaci\u00f3n ni seguridad en el servidor web.</p> <p>-No se utilizan librer\u00edas externas de servidores avanzados, \u00fanicamente la librer\u00eda nativa WebServer.h.</p> <p>-El control se limita a encendido y apagado, sin regulaci\u00f3n de intensidad (PWM).</p>"},{"location":"PR%C3%81CTICA%207/#4-resultados","title":"4) Resultados","text":"<p>Al cargar el programa en el ESP32 y abrir el monitor serial, se muestra la direcci\u00f3n IP asignada por la red WiFi, la cual se introduce en el navegador para acceder al servidor.</p> <p>La p\u00e1gina principal permite controlar un LED mediante un bot\u00f3n que cambia din\u00e1micamente su estado de \u201cON\u201d a \u201cOFF\u201d. Para los otros dos LEDs, se accede a trav\u00e9s de rutas espec\u00edficas (/on1, /off1, /on2, /off2) en la URL, lo cual permite verificar el funcionamiento del servidor al interpretar diferentes solicitudes HTTP.</p> <p>El funcionamiento observado fue el siguiente: Al presionar el bot\u00f3n en la p\u00e1gina, el LED conectado al pin 20 cambia entre encendido y apagado. Al introducir manualmente la ruta /on1 o /off1, el LED en el pin 19 responde correctamente. De igual manera, con las rutas /on2 y /off2 se controla el LED del pin 21 Esto valida la correcta integraci\u00f3n entre la programaci\u00f3n del ESP32, el servidor web y el hardware f\u00edsico.</p> <p></p>"},{"location":"PR%C3%81CTICA%207/#_1","title":"\ud83d\udcda Pr\u00e1ctica 7: Control de LEDs con ESP32 mediante Servidor Web","text":""},{"location":"PR%C3%81CTICA%207/#6-archivos-adjuntos","title":"6) Archivos Adjuntos","text":"<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;WebServer.h&gt;\n\nconst char* ssid = \"iPhone\";\nconst char* password = \"karennajera\";\n\nWebServer server(80);\n\nconst int ledPin = 20;  \nconst int ledPin1 = 19;\nconst int ledPin2 = 21;\nString ledState = \"OFF\";\nString ledState1 = \"OFF\";\nString ledState2 = \"OFF\";\n\nvoid handleRoot() {\n  String html = \"&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset='UTF-8'&gt;&lt;title&gt;ESP32 LED Control&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\";\n  html += \"&lt;h1&gt;ESP32 LED Control&lt;/h1&gt;\";\n  html += \"&lt;p&gt;LED is \" + ledState + \"&lt;/p&gt;\";\n  if (ledState == \"OFF\")\n    html += \"&lt;a href=\\\"/on\\\"&gt;&lt;button&gt;Turn On&lt;/button&gt;&lt;/a&gt;\";\n  else\n    html += \"&lt;a href=\\\"/off\\\"&gt;&lt;button&gt;Turn Off&lt;/button&gt;&lt;/a&gt;\";\n  html += \"&lt;/body&gt;&lt;/html&gt;\";\n  server.send(200, \"text/html\", html);\n}\n\nvoid handleOn() {\n  digitalWrite(ledPin, HIGH);\n  ledState = \"ON\";\n  handleRoot();\n}\n\nvoid handleOff() {\n  digitalWrite(ledPin, LOW);\n  ledState = \"OFF\";\n  handleRoot();\n}\n\nvoid handleOn1() {\n  digitalWrite(ledPin1, HIGH);\n  ledState1 = \"ON\";\n  handleRoot();\n}\nvoid handleOff1() {\n  digitalWrite(ledPin1, LOW);\n  ledState1 = \"OFF\";\n  handleRoot();\n}\nvoid handleOn2() {\n  digitalWrite(ledPin2, HIGH);\n  ledState2 = \"ON\";\n  handleRoot();\n}\nvoid handleOff2() {\n  digitalWrite(ledPin2, LOW);\n  ledState2 = \"OFF\";\n  handleRoot();\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(ledPin, OUTPUT);\n  pinMode(ledPin1, OUTPUT);\n  pinMode(ledPin2, OUTPUT);\n  digitalWrite(ledPin, LOW);\n  digitalWrite(ledPin1, LOW);\n  digitalWrite(ledPin2, LOW);\n\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\\nWiFi connected\");\n  Serial.println(WiFi.localIP());\n\n  server.on(\"/\", handleRoot);\n  server.on(\"/on\", handleOn);\n  server.on(\"/off\", handleOff);\n  server.on(\"/on1\", handleOn1);\n  server.on(\"/off1\", handleOff1);\n  server.on(\"/on2\", handleOn2);\n  server.on(\"/off2\", handleOff2);\n\n  server.begin();\n  Serial.println(\"Server started\");\n}\n\nvoid loop() {\n  server.handleClient();\n}\n</code></pre>"},{"location":"PR%C3%81CTICA%207/#5-conclusion","title":"5) Conclusi\u00f3n","text":"<p>La pr\u00e1ctica permiti\u00f3 comprobar que el ESP32 puede actuar como un servidor web capaz de controlar perif\u00e9ricos en tiempo real. A trav\u00e9s de una interfaz sencilla en HTML, se logr\u00f3 el encendido y apagado de LEDs de forma remota desde cualquier dispositivo conectado a la misma red. Este ejercicio constituye un ejemplo b\u00e1sico de aplicaciones IoT, donde los microcontroladores conectados a internet permiten interactuar con el entorno f\u00edsico. Los conocimientos adquiridos son fundamentales para proyectos m\u00e1s complejos como automatizaci\u00f3n del hogar, control de maquinaria industrial o monitoreo de sistemas.</p>"},{"location":"PR%C3%81CTICA%208/","title":"\ud83d\udcda Pr\u00e1ctica 8: Control de LEDs con ESP32 mediante Servidor Web Interactivo","text":""},{"location":"PR%C3%81CTICA%208/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Karen Najera y Arith Maldonado</li> <li>Curso / Asignatura: Elementos programables II </li> <li>Fecha: 29/09/2025 </li> <li>Descripci\u00f3n breve: En esta pr\u00e1ctica se configur\u00f3 un ESP32 como servidor web para controlar dos LEDs mediante sliders (control PWM) y uno adicional a trav\u00e9s de un bot\u00f3n de encendido/apagado en una interfaz web. Tambi\u00e9n se incorpor\u00f3 una caja de texto para enviar datos al ESP32 desde la misma p\u00e1gina. Todo esto permite simular una interfaz de control b\u00e1sica para un sistema embebido conectado a red, sentando las bases para aplicaciones IoT.</li> </ul>"},{"location":"PR%C3%81CTICA%208/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Comprender e implementar un servidor web sobre el ESP32 que permita el control interactivo de perif\u00e9ricos en tiempo real a trav\u00e9s de una interfaz web.</li> <li>Espec\u00edficos:</li> <li>Configurar una p\u00e1gina HTML embebida que incluya controles interactivos como sliders, botones y cajas de texto.</li> <li>Implementar funciones en el servidor web para recibir valores y aplicarlos al hardware f\u00edsico (pines PWM y digitales).</li> <li>Utilizar funciones de mapeo PWM para controlar brillo o velocidad de motores.</li> </ul>"},{"location":"PR%C3%81CTICA%208/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye:  -Control de dos salidas PWM mediante sliders en una interfaz web.</li> </ul> <p>-Control de un LED (ON/OFF) mediante un bot\u00f3n en la misma p\u00e1gina.</p> <p>-Recepci\u00f3n de texto desde una caja de entrada y su impresi\u00f3n en el monitor serial.</p> <p>-No se implementa autenticaci\u00f3n ni seguridad en el servidor web.</p> <p>-No se utilizan librer\u00edas externas avanzadas, \u00fanicamente WiFi.h y WebServer.h..</p> <p>-No se contempla la regulaci\u00f3n anal\u00f3gica directa del LED controlado por bot\u00f3n (solo ON/OFF)</p>"},{"location":"PR%C3%81CTICA%208/#4-resultados","title":"4) Resultados","text":"<p>_Al subir el programa al ESP32 y conectarlo a la red WiFi, el monitor serial muestra la direcci\u00f3n IP local asignada. Esta direcci\u00f3n es introducida en un navegador dentro de la misma red para abrir la interfaz web.</p> <p>La p\u00e1gina principal permite controlar un LED mediante un bot\u00f3n que cambia din\u00e1micamente su estado de \u201cON\u201d a \u201cOFF\u201d. Para los otros dos LEDs, se accede a trav\u00e9s de rutas espec\u00edficas (/on1, /off1, /on2, /off2) en la URL, lo cual permite verificar el funcionamiento del servidor al interpretar diferentes solicitudes HTTP.</p> <p>El bot\u00f3n HTML permite encender o apagar un LED (pin LED_BUILTIN) de forma remota, con cambios din\u00e1micos en el texto del bot\u00f3n y estado del LED.</p> <p>Los sliders permiten modificar valores de 0 a 180, los cuales son mapeados a un rango de se\u00f1al PWM (205 a 410). Esto se refleja en la intensidad de salida en los pines definidos por #define pwm 3 y #define pwm1 2, ideal para el control de brillo de LEDs o velocidad de servomotores.</p> <p>Al escribir en la caja de texto y presionar \u201cEnviar\u201d, el valor se muestra en el monitor serial como confirmaci\u00f3n de recepci\u00f3n.</p> <p>Todas las acciones generan peticiones HTTP (GET) que el servidor del ESP32 interpreta correctamente, generando una respuesta inmediata y modificando salidas f\u00edsicas.</p>"},{"location":"PR%C3%81CTICA%208/#6-archivos-adjuntos","title":"6) Archivos Adjuntos","text":"<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;WebServer.h&gt;\n\n#define pwm 3\n#define pwm1 2\n\nconst char* ssid = \"iPhone\";\nconst char* password = \"karennajera\";\n\nWebServer servidor(80);\n\nconst int ledPin = LED_BUILTIN;\nString ledState = \"OFF\";\nint sliderValue = 0;\nint sliderValue1 = 0;\n\nconst char htmlTemplate[] PROGMEM = R\"rawliteral(\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Control de LED ESP32&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Control de LED ESP32&lt;/h1&gt;\n    &lt;p&gt;El LED est\u00e1 %LED_STATE%&lt;/p&gt;\n    &lt;a href=\"/%LINK%\"&gt;&lt;button&gt;%BUTTON_TEXT%&lt;/button&gt;&lt;/a&gt;\n    &lt;br&gt;&lt;br&gt;\n    &lt;h2&gt;Control del Slider&lt;/h2&gt;\n    &lt;input type=\"range\" min=\"0\" max=\"180\" value=\"%SLIDER_VALUE%\" id=\"slider\" oninput=\"updateSlider(this.value)\"&gt;\n    &lt;span id=\"sliderValue\"&gt;%SLIDER_VALUE%&lt;/span&gt;\n    &lt;br&gt;&lt;br&gt;\n    &lt;h2&gt;Segundo Slider&lt;/h2&gt;\n    &lt;input type=\"range\" min=\"0\" max=\"180\" value=\"%SLIDER_VALUE1%\" id=\"slider1\" oninput=\"updateSlider1(this.value)\"&gt;\n    &lt;span id=\"sliderValue1\"&gt;%SLIDER_VALUE1%&lt;/span&gt;\n    &lt;br&gt;&lt;br&gt;\n    &lt;h2&gt;Ingresar Texto&lt;/h2&gt;\n    &lt;input type=\"text\" id=\"txtInput\" placeholder=\"Escribe algo...\"&gt;\n    &lt;button onclick=\"sendText()\"&gt;Enviar&lt;/button&gt;\n\n    &lt;script&gt;\n      function updateSlider(value) {\n        document.getElementById('sliderValue').innerText = value;\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", \"/slider?value=\" + encodeURIComponent(value), true);\n        xhr.send();\n      }\n      function updateSlider1(value) {\n        document.getElementById('sliderValue1').innerText = value;\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", \"/slider1?value=\" + encodeURIComponent(value), true);\n        xhr.send();\n      }\n      function sendText() {\n        var textValue = document.getElementById('txtInput').value;\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", \"/textbox?value=\" + encodeURIComponent(textValue), true);\n        xhr.send();\n      }\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n)rawliteral;\n\nvoid handleroot() {\n  String html = String(htmlTemplate);\n  html.replace(\"%LED_STATE%\", ledState);\n  html.replace(\"%SLIDER_VALUE%\", String(sliderValue));\n  html.replace(\"%SLIDER_VALUE1%\", String(sliderValue1));\n  if (ledState == \"OFF\") {\n    html.replace(\"%LINK%\", \"ON\");\n    html.replace(\"%BUTTON_TEXT%\", \"Encender\");\n  } else {\n    html.replace(\"%LINK%\", \"OFF\");\n    html.replace(\"%BUTTON_TEXT%\", \"Apagar\");\n  }\n  servidor.send(200, \"text/html\", html);\n}\n\nvoid handleOn() {\n  digitalWrite(ledPin, HIGH);\n  ledState = \"ON\";\n  handleroot();\n}\n\nvoid handleOff() {\n  digitalWrite(ledPin, LOW);\n  ledState = \"OFF\";\n  handleroot();\n}\n\nvoid handleSlider() {\n  if (servidor.hasArg(\"value\")) {\n    sliderValue = servidor.arg(\"value\").toInt();\n    Serial.println(\"Valor del slider: \" + String(sliderValue));\n    int duty = map(sliderValue, 0, 180, 205, 410);\n    ledcWrite(pwm, duty);\n  }\n  servidor.send(200, \"text/plain\", \"OK\");\n}\n\nvoid handleSlider1() {\n  if (servidor.hasArg(\"value\")) {\n    sliderValue1 = servidor.arg(\"value\").toInt();\n    Serial.println(\"Valor del segundo slider: \" + String(sliderValue1));\n    int duty1 = map(sliderValue1, 0, 180, 205, 410);\n    ledcWrite(pwm1, duty1);\n  }\n  servidor.send(200, \"text/plain\", \"OK\");\n}\n\nvoid handleTextbox() {\n  if (servidor.hasArg(\"value\")) {\n    String textValue = servidor.arg(\"value\");\n    Serial.println(\"Texto recibido: \" + textValue);\n  }\n  servidor.send(200, \"text/plain\", \"OK\");\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(ledPin, OUTPUT);\n  digitalWrite(ledPin, LOW);\n  ledcAttachChannel(pwm, 50, 12, 0);\n  ledcAttachChannel(pwm1, 50, 12, 1);\n\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n\n  Serial.println(\"\\nWiFi conectado\");\n  Serial.println(WiFi.localIP());\n\n  servidor.on(\"/\", handleroot);\n  servidor.on(\"/ON\", handleOn);\n  servidor.on(\"/OFF\", handleOff);\n  servidor.on(\"/slider\", handleSlider);\n  servidor.on(\"/slider1\", handleSlider1);\n  servidor.on(\"/textbox\", handle\n</code></pre>"},{"location":"PR%C3%81CTICA%208/#5-conclusion","title":"5) Conclusi\u00f3n","text":"<p>La pr\u00e1ctica permiti\u00f3 comprobar que el ESP32 puede actuar como un servidor web funcional que permite controlar perif\u00e9ricos en tiempo real desde una interfaz gr\u00e1fica. El sistema implementado constituye una base s\u00f3lida para aplicaciones m\u00e1s complejas del Internet de las Cosas (IoT), como dom\u00f3tica, monitoreo remoto o automatizaci\u00f3n industrial.</p> <p>La integraci\u00f3n entre HTML, JavaScript y el servidor embebido del ESP32 permite la creaci\u00f3n de interfaces intuitivas que facilitan la interacci\u00f3n hombre-m\u00e1quina sin necesidad de aplicaciones externas. Adem\u00e1s, el manejo de se\u00f1ales PWM desde el navegador extiende la utilidad del sistema para control preciso de actuadores. Se concluye que el ESP32 es una herramienta poderosa, flexible y accesible para el desarrollo de sistemas embebidos conectados a red..</p>"},{"location":"PR%C3%81CTICA%209/","title":"\ud83d\udef0\ufe0f Pr\u00e1ctica 9 (P9): Comunicaci\u00f3n ESP-NOW con 3 botones y 3 LEDs","text":""},{"location":"PR%C3%81CTICA%209/#1-resumen","title":"1) Resumen","text":"<ul> <li>Rol del nodo: ESP32-C6 en WIFI_STA usando ESP-NOW. Lee 3 botones (GPIO 2, 3, 4) y env\u00eda su estado a tres peers (por MAC). Adem\u00e1s recibe paquetes y conmuta 3 LEDs (GPIO 10, 11, 12) seg\u00fan el origen y el payload.</li> </ul>"},{"location":"PR%C3%81CTICA%209/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Configurar ESP-NOW y registrar tres peers por direcci\u00f3n MAC.</li> <li>Enviar el estado de cada bot\u00f3n al peer correspondiente.</li> <li>Recibir datos y accionar LEDs en funci\u00f3n de la MAC fuente y del campo b del payload.</li> <li>Verificar el funcionamiento mediante logs en el Monitor Serie.</li> </ul>"},{"location":"PR%C3%81CTICA%209/#3-materiales","title":"3) Materiales","text":"<ul> <li>ESP32-C6 Dev Module  </li> <li>3 pulsadores (conexi\u00f3n pull-down o pull-up)  </li> <li>3 LEDs con resistencias (GPIO 10, 11, 12)  </li> <li>Protoboard y jumpers  </li> <li>Arduino IDE (core ESP32)</li> </ul> <p>Nota el\u00e9ctrica: Comparte GND entre todos los elementos y usa resistencias para LEDs. Define consistentemente pull-up/pull-down.</p>"},{"location":"PR%C3%81CTICA%209/#4-codigo-p9","title":"4) C\u00f3digo (P9)","text":"<pre><code>#include &lt;esp_now.h&gt;\n#include &lt;WiFi.h&gt;\nuint8_t broadcastAddress[] = {0x7C, 0x2C, 0x67, 0x55, 0xD6, 0x88}; //mAC ADREES DEL OTRO ESP32\nuint8_t broadcastAddress2[] = {0x7C, 0x2C, 0x67, 0x55, 0xD8, 0xDC};\nuint8_t broadcastAddress3[] = {0x7C, 0x2C, 0x67, 0x55, 0xD4, 0xE0};\n\nint led1 = 10;\nint led2 = 11;\nint led3 = 12;\nint boton1 = 2;\nint boton2 = 3;\nint boton3 = 4;\n\n//Enviar\n// Estructura de datos (m\u00e1x. 250 bytes)\n\ntypedef struct struct_msj {\n  char a[32];\n  int b;\n  float c;\n  bool d;\n} struct_msj;\nstruct_msj datosEnviados;\nstruct_msj datosRecibidos;\nstruct_msj datosEnviados2;\nstruct_msj datosRecibidos2;\nstruct_msj datosEnviados3;\nstruct_msj datosRecibidos3;\n\nesp_now_peer_info_t peerInfo;\nesp_now_peer_info_t peerInfo2;\nesp_now_peer_info_t peerInfo3;\nvoid OnDataRecv(const esp_now_recv_info_t *info, const uint8_t *tempData, int tam) {\n  memcpy(&amp;datosRecibidos, tempData, sizeof(datosRecibidos));\n  // Imprimir informaci\u00f3n de la fuente (opcional)\n  char macStr[18];\n  snprintf(macStr, sizeof(macStr),\n           \"%02X:%02X:%02X:%02X:%02X:%02X\",\n           info-&gt;src_addr[0], info-&gt;src_addr[1], info-&gt;src_addr[2],\n           info-&gt;src_addr[3], info-&gt;src_addr[4], info-&gt;src_addr[5]);\n  Serial.printf(\"Datos recibidos de: %s\\n\", macStr);\n  //Serial.printf(\"Bytes recibidos: %d\\n\", tam);\n  if(info-&gt;src_addr[5] == 0x88)\n  {\n    if (datosRecibidos.b == 1) {\n      digitalWrite(led1, HIGH);\n    }\n    else {\n      digitalWrite(led1, LOW);\n    }\n  }\n  if(info-&gt;src_addr[5] == 0xE0)\n  {\n    if (datosRecibidos.b==1) {\n      digitalWrite(led2, HIGH);\n    }\n    else {\n      digitalWrite(led2, LOW);\n    }\n  }\n  if(info-&gt;src_addr[5] == 0xDC)\n  {\n    if (datosRecibidos.b == 1) {\n      digitalWrite(led3, HIGH);\n    }\n    else {\n      digitalWrite(led3, LOW);\n    }\n  }\n\n  Serial.printf(\"Int: %d\\n\", datosRecibidos.b);\n  //Serial.printf(\"Float: %.2f\\n\", datosRecibidos.c);\n  //Serial.printf(\"Bool: %d\\n\\n\", datosRecibidos.d);\n}\nvoid setup()\n{\n  Serial.begin(115200);\n  WiFi.mode(WIFI_STA);\n  pinMode(boton1, INPUT);\n  pinMode(boton2, INPUT);\n  pinMode(boton3, INPUT);\n  pinMode(led1, OUTPUT);\n  pinMode(led2, OUTPUT);\n  pinMode(led3, OUTPUT);\n  if (esp_now_init() != ESP_OK)\n  {\n    Serial.println(\"Error inicializando ESP-NOW\");\n    return;\n  }\n  memset(&amp;peerInfo, 0, sizeof(peerInfo));\n  memcpy(peerInfo.peer_addr, broadcastAddress, 6);\n  peerInfo.channel = 0;\n  peerInfo.encrypt = false;\n  if (esp_now_add_peer(&amp;peerInfo) != ESP_OK)\n  {\n    Serial.println(\"No se pudo agregar el peer\");\n    return;\n  }\n  // Configurar peer\n  memset(&amp;peerInfo2, 0, sizeof(peerInfo2));\n  memcpy(peerInfo2.peer_addr, broadcastAddress2, 6);\n  peerInfo.channel = 0;\n  peerInfo.encrypt = false;\n  if (esp_now_add_peer(&amp;peerInfo2) != ESP_OK)\n  {\n    Serial.println(\"No se pudo agregar el peer\");\n    return;\n  }\n    memset(&amp;peerInfo3, 0, sizeof(peerInfo3));\n  memcpy(peerInfo3.peer_addr, broadcastAddress3, 6);\n  peerInfo.channel = 0;\n  peerInfo.encrypt = false;\n  if (esp_now_add_peer(&amp;peerInfo3) != ESP_OK)\n  {\n    Serial.println(\"No se pudo agregar el peer\");\n    return;\n  }\n  Serial.println(\"ESP-NOW listo para enviar\");\n  esp_now_register_recv_cb(OnDataRecv);\n}\n\nvoid loop()\n{\n  //aqui imprime estado botones\n  Serial.print(\"Bot\u00f3n 1: \");\n  Serial.print(digitalRead(boton1));\n  Serial.print(\" | Bot\u00f3n 2: \");\n  Serial.print(digitalRead(boton2));\n  Serial.print(\" | Bot\u00f3n 3: \");\n  Serial.println(digitalRead(boton3));\n\n  strcpy(datosEnviados.a, \"Hola Mundo\");\n  datosEnviados.c = 3.14;\n  datosEnviados.d = true;\n\n\n  if(digitalRead(boton1) == HIGH){\n    datosEnviados.b = 1;\n    esp_err_t result1 = esp_now_send(broadcastAddress,\n                                    (uint8_t *)&amp;datosEnviados,\n                                    sizeof(datosEnviados));\n  }\n  else if(digitalRead(boton1) == LOW){\n    datosEnviados.b = 0;\n    esp_err_t result1 = esp_now_send(broadcastAddress,\n                                  (uint8_t *)&amp;datosEnviados,\n                                  sizeof(datosEnviados));\n  }\n  if(digitalRead(boton2) == HIGH){\n  datosEnviados.b = 1;\n  esp_err_t result2 = esp_now_send(broadcastAddress2,\n                                  (uint8_t *)&amp;datosEnviados,\n                                  sizeof(datosEnviados));  \n  }\n  else if(digitalRead(boton2) == LOW){\n    datosEnviados.b = 0;\n    esp_err_t result2 = esp_now_send(broadcastAddress2,\n                                  (uint8_t *)&amp;datosEnviados,\n                                  sizeof(datosEnviados));\n  }\n\n  if(digitalRead(boton3) == HIGH){\n  datosEnviados.b = 1;\n  esp_err_t result3 = esp_now_send(broadcastAddress3,\n                                  (uint8_t *)&amp;datosEnviados,\n                                  sizeof(datosEnviados));\n  }\n  else if(digitalRead(boton3) == LOW){\n    datosEnviados.b = 0;\n    esp_err_t result3 = esp_now_send(broadcastAddress3,\n                                  (uint8_t *)&amp;datosEnviados,\n                                  sizeof(datosEnviados));\n  }\n\n  delay(2000);\n}\n</code></pre>"},{"location":"Plataforma%20PD/","title":"Proyecto Final (PF): Plataforma de Balance 3-DOF con Visi\u00f3n por Computadora","text":""},{"location":"Plataforma%20PD/#1-resumen","title":"1) Resumen","text":"<ul> <li>Se desarroll\u00f3 una plataforma de balance de tres grados de libertad (3-DOF) controlada mediante visi\u00f3n por computadora en tiempo real y comunicaci\u00f3n inal\u00e1mbrica Bluetooth Serial hacia un ESP32.</li> <li>Se implementaron dos modos de operaci\u00f3n:</li> <li>Control por Mano (MediaPipe Hands): La c\u00e1mara identifica la orientaci\u00f3n de la mano y traduce roll/pitch en \u00e1ngulos l\u00f3gicos para los servomotores.</li> <li>Control PD por C\u00e1mara Frontal: La c\u00e1mara observa la plataforma, detecta la posici\u00f3n de la pelota y aplica un control PD para regresarla al centro.</li> <li>El ESP32 convierte los \u00e1ngulos en PWM para los servos e implementa una rampa suave para evitar golpes mec\u00e1nicos.</li> </ul>"},{"location":"Plataforma%20PD/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Implementar visi\u00f3n por computadora para el control en tiempo real de una plataforma 3-DOF.</li> <li>Procesar se\u00f1ales de Bluetooth Serial en el ESP32 para recibir comandos de \u00e1ngulo.</li> <li>Controlar 3 servos usando \u00e1ngulos l\u00f3gicos con mapeo l\u00f3gico\u2013f\u00edsico e interpolaci\u00f3n suave (rampa).</li> <li>Implementar un control PD que estabilice una pelota sobre la plataforma.</li> <li>Validar el desempe\u00f1o mec\u00e1nico y de control mediante pruebas f\u00edsicas (modo mano y modo pelota).</li> </ul>"},{"location":"Plataforma%20PD/#3-materiales","title":"3) Materiales","text":"<ul> <li>1 \u00d7 ESP32 DevKit </li> <li>3 \u00d7 Servomotores SG90 o similares  </li> <li>Estructura mec\u00e1nica de plataforma 3-DOF </li> <li>Fuente de 5 V para servos  </li> <li>1 \u00d7 C\u00e1mara web </li> <li>PC con Python 3 y librer\u00edas:</li> <li><code>opencv-python</code> </li> <li><code>numpy</code> </li> <li><code>mediapipe</code> </li> <li><code>bluetooth</code> / PyBluez  </li> <li>Cables, protoboard y elementos mec\u00e1nicos seg\u00fan el dise\u00f1o</li> </ul> <p>Nota el\u00e9ctrica: Todos los componentes deben compartir GND y los servos deben alimentarse con 5 V externos.</p>"},{"location":"Plataforma%20PD/#4-codigo-control-por-mano-python","title":"4) C\u00f3digo \u2014 Control por Mano (Python)","text":""},{"location":"Plataforma%20PD/#import-cv2-import-numpy-as-np-import-bluetooth-import-time-import-mediapipe-as-mp-bluetooth-device_mac-f024f90c4cde-misma-mac-port-1-parametros-mapeo-posiciones-neutras-de-la-plataforma-en-grados-logicos-0-180-neut_izq-90-neut_der-90-neut_vert-60-cuanto-giro-de-mano-consideramos-util-en-grados-max_hand_tilt_x-300-30-de-roll-mano-max_hand_tilt_y-300-30-de-pitch-mano-cuanto-puede-moverse-el-servo-alrededor-de-su-neutro-max_servo_offset_x-400-servos-izqder-40-max_servo_offset_y-300-servo-vertical-30-invertir-ejes-si-hace-falta-invert_x-true-invert_y-true-limite-de-frecuencia-de-envio-min_dt_cmd-0015-15-ms-66-hz-max-last_cmd_time-00-referencias-de-angulo-se-calibran-con-c-base_anglex-none-angulo-neutro-entre-indice-anular-base_angley-none-angulo-neutro-entre-muneca-dedo-medio-conexion-bluetooth-sock-none-printintentando-conectar-al-esp32-por-bluetooth-device_mac-while-true-try-sock-bluetoothbluetoothsocket-socksettimeout10-sockconnectdevice_mac-port-print-conectado-al-esp32-break-except-exception-as-e-printerror-de-conexion-reintentando-e-timesleep1-mediapipe-hands-mp_hands-mpsolutionshands-hands-mp_handshandsmax_num_hands1-min_detection_confidence05-min_tracking_confidence05-mp_draw-mpsolutionsdrawing_utils-camara-video-cv2videocapture0-usa-0-o-1-segun-tu-camara-def-calc_anglep1-p2-devuelve-angulo-rad-deg-de-la-linea-p1-p2-respecto-al-eje-x-x1-y1-p1-x2-y2-p2-dx-x2-x1-dy-y2-y1-theta-nparctan2dy-dx-radianes-theta_deg-npdegreestheta-grados-return-theta-theta_deg-while-true-ok-frame-videoread-if-not-ok-break-frame-cv2flipframe-1-h-w-frameshape2-now-timetime-send_allowed-now-last_cmd_time-min_dt_cmd-procesar-mano-img_rgb-cv2cvtcolorframe-cv2color_bgr2rgb-results-handsprocessimg_rgb-hay_mano-false-anglex_deg-none-angley_deg-none-if-resultsmulti_hand_landmarks-hay_mano-true-hand_landmarks-resultsmulti_hand_landmarks0-mp_drawdraw_landmarksframe-hand_landmarks-mp_handshand_connections-puntos-clave-idx_tip-hand_landmarkslandmark8-indice-mid_tip-hand_landmarkslandmark12-medio-ring_tip-hand_landmarkslandmark16-anular-wrist-hand_landmarkslandmark0-muneca-def-to_pxlm-return-intlmx-w-intlmy-h-idx_pt-to_pxidx_tip-mid_pt-to_pxmid_tip-ring_pt-to_pxring_tip-wrist_pt-to_pxwrist-dibujar-puntos-rojos-for-p-in-idx_pt-mid_pt-ring_pt-wrist_pt-cv2circleframe-p-8-0-0-255-1-linea-verde-indice-anular-roll-x-cv2lineframe-idx_pt-ring_pt-0-255-0-3-_-anglex_deg-calc_angleidx_pt-ring_pt-linea-magenta-muneca-dedo-medio-pitch-y-cv2lineframe-wrist_pt-mid_pt-255-0-255-3-_-angley_deg-calc_anglewrist_pt-mid_pt-centro-aproximado-de-la-mano-turquesa-cx-intwrist_pt0-idx_pt0-ring_pt0-3-cy-intwrist_pt1-idx_pt1-ring_pt1-3-cv2circleframe-cx-cy-8-255-255-0-1-mostrar-angulos-cv2puttextframe-faxanglex_deg72f-deg-10-25-cv2font_hershey_simplex-06-255255255-2-cv2puttextframe-fayangley_deg72f-deg-10-50-cv2font_hershey_simplex-06-255255255-2-si-ya-hay-calibracion-mapear-directo-a-angulos-de-servos-if-base_anglex-is-not-none-and-base_angley-is-not-none-diferencias-de-angulo-respecto-a-la-mano-neutra-dax-anglex_deg-base_anglex-roll-relativo-day-angley_deg-base_angley-pitch-relativo-normalizar-al-rango-1-1-segun-el-maximo-giro-que-consideras-dax_norm-npclipdax-max_hand_tilt_x-10-10-day_norm-npclipday-max_hand_tilt_y-10-10-invertir-si-quieres-que-gire-al-reves-if-invert_x-dax_norm-dax_norm-if-invert_y-day_norm-day_norm-offset-en-grados-de-servo-servo_off_x-dax_norm-max_servo_offset_x-servo_off_y-day_norm-max_servo_offset_y-angulos-logicos-absolutos-para-cada-servo-ang_izq-neut_izq-servo_off_x-ang_der-neut_der-servo_off_x-ang_vert-neut_vert-servo_off_y-limitar-0180-ang_izq-intnpclipang_izq-0-180-ang_der-intnpclipang_der-0-180-ang_vert-intnpclipang_vert-0-180-cv2puttextframe-fizqang_izq-derang_der-vertang_vert-10-75-cv2font_hershey_simplex-06-0255255-2-enviar-al-esp32-if-send_allowed-try-cmd-fangang_izqang_derang_vertn-socksendcmdencode-printcmd-cmdstrip-last_cmd_time-now-except-exception-as-e-print-error-al-enviar-ang-e-else-cv2puttextframe-presiona-c-para-calibrar-mano-neutra-y-mandar-zero-10-h-10-cv2font_hershey_simplex-06-0-0-255-2-else-cv2puttextframe-no-hand-10-25-cv2font_hershey_simplex-07-0-0-255-2-sin-mano-opcional-mandar-lost-if-send_allowed-try-socksendblostn-last_cmd_time-now-except-exception-as-e-print-error-al-enviar-lost-e-cv2imshowhand-angle-direct-control-frame-key-cv2waitkey1-0xff-if-key-ordq-break-elif-key-ordc-calibrar-mano-neutra-si-hay-angulos-validos-if-anglex_deg-is-not-none-and-angley_deg-is-not-none-base_anglex-anglex_deg-base_angley-angley_deg-printfcalibrado-base_anglexbase_anglex2f-base_angleybase_angley2f-mandar-comando-zero-para-llevar-servos-a-180-fisicos-try-socksendbzeron-last_cmd_time-timetime-printcomando-zero-enviado-servos-a-180-fisico-except-exception-as-e-print-error-al-enviar-zero-e-videorelease-sockclose-cv2destroyallwindows","title":"<pre><code>import cv2\nimport numpy as np\nimport bluetooth\nimport time\nimport mediapipe as mp\n\n# ========= BLUETOOTH =========\ndevice_mac = \"F0:24:F9:0C:4C:DE\"   # &lt;-- MISMA MAC\nport = 1\n\n# ========= PAR\u00c1METROS MAPEO =========\n# Posiciones \"neutras\" de la plataforma en grados l\u00f3gicos (0-180)\nNEUT_IZQ  = 90\nNEUT_DER  = 90\nNEUT_VERT = 60\n\n# Cu\u00e1nto giro de mano consideramos \u00fatil (en grados)\nMAX_HAND_TILT_X = 30.0   # \u00b130\u00b0 de roll mano\nMAX_HAND_TILT_Y = 30.0   # \u00b130\u00b0 de pitch mano\n\n# Cu\u00e1nto puede moverse el servo alrededor de su neutro\nMAX_SERVO_OFFSET_X = 40.0  # servos izq/der \u00b140\u00b0\nMAX_SERVO_OFFSET_Y = 30.0  # servo vertical \u00b130\u00b0\n\n# Invertir ejes si hace falta\nINVERT_X = True\nINVERT_Y = True\n\n# L\u00edmite de frecuencia de env\u00edo\nMIN_DT_CMD = 0.015  # 15 ms (~66 Hz m\u00e1x)\n\nlast_cmd_time = 0.0\n\n# Referencias de \u00e1ngulo (se calibran con 'c')\nbase_angleX = None   # \u00e1ngulo neutro entre \u00edndice \u2194 anular\nbase_angleY = None   # \u00e1ngulo neutro entre mu\u00f1eca \u2194 dedo medio\n\n# ======== CONEXI\u00d3N BLUETOOTH ========\nsock = None\nprint(\"Intentando conectar al ESP32 por Bluetooth...\", device_mac)\nwhile True:\n    try:\n        sock = bluetooth.BluetoothSocket()\n        sock.settimeout(10)\n        sock.connect((device_mac, port))\n        print(\"\u2705 Conectado al ESP32!\")\n        break\n    except Exception as e:\n        print(\"Error de conexi\u00f3n, reintentando:\", e)\n        time.sleep(1)\n\n# ======== MEDIAPIPE HANDS ========\nmp_hands = mp.solutions.hands\nhands = mp_hands.Hands(max_num_hands=1,\n                       min_detection_confidence=0.5,\n                       min_tracking_confidence=0.5)\nmp_draw = mp.solutions.drawing_utils\n\n# ======== C\u00c1MARA ========\nvideo = cv2.VideoCapture(0)  # usa 0 o 1 seg\u00fan tu c\u00e1mara\n\ndef calc_angle(p1, p2):\n    \"\"\"Devuelve \u00e1ngulo (rad, deg) de la l\u00ednea p1-&gt;p2 respecto al eje X.\"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    dx = x2 - x1\n    dy = y2 - y1\n    theta = np.arctan2(dy, dx)          # radianes\n    theta_deg = np.degrees(theta)       # grados\n    return theta, theta_deg\n\nwhile True:\n    ok, frame = video.read()\n    if not ok:\n        break\n\n    frame = cv2.flip(frame, 1)\n    h, w = frame.shape[:2]\n\n    now = time.time()\n    send_allowed = (now - last_cmd_time) &gt;= MIN_DT_CMD\n\n    # Procesar mano\n    img_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n    results = hands.process(img_rgb)\n\n    hay_mano = False\n    angleX_deg = None\n    angleY_deg = None\n\n    if results.multi_hand_landmarks:\n        hay_mano = True\n        hand_landmarks = results.multi_hand_landmarks[0]\n        mp_draw.draw_landmarks(frame, hand_landmarks, mp_hands.HAND_CONNECTIONS)\n\n        # ====== PUNTOS CLAVE ======\n        idx_tip  = hand_landmarks.landmark[8]   # \u00edndice\n        mid_tip  = hand_landmarks.landmark[12]  # medio\n        ring_tip = hand_landmarks.landmark[16]  # anular\n        wrist    = hand_landmarks.landmark[0]   # mu\u00f1eca\n\n        def to_px(lm):\n            return int(lm.x * w), int(lm.y * h)\n\n        idx_pt  = to_px(idx_tip)\n        mid_pt  = to_px(mid_tip)\n        ring_pt = to_px(ring_tip)\n        wrist_pt= to_px(wrist)\n\n        # Dibujar puntos (rojos)\n        for p in [idx_pt, mid_pt, ring_pt, wrist_pt]:\n            cv2.circle(frame, p, 8, (0, 0, 255), -1)\n\n        # ====== L\u00cdNEA VERDE: \u00edndice \u2194 anular (roll / X) ======\n        cv2.line(frame, idx_pt, ring_pt, (0, 255, 0), 3)\n        _, angleX_deg = calc_angle(idx_pt, ring_pt)\n\n        # ====== L\u00cdNEA MAGENTA: mu\u00f1eca \u2194 dedo medio (pitch / Y) ======\n        cv2.line(frame, wrist_pt, mid_pt, (255, 0, 255), 3)\n        _, angleY_deg = calc_angle(wrist_pt, mid_pt)\n\n        # Centro aproximado de la mano (turquesa)\n        cx = int((wrist_pt[0] + idx_pt[0] + ring_pt[0]) / 3)\n        cy = int((wrist_pt[1] + idx_pt[1] + ring_pt[1]) / 3)\n        cv2.circle(frame, (cx, cy), 8, (255, 255, 0), -1)\n\n        # Mostrar \u00e1ngulos\n        cv2.putText(frame, f\"AX:{angleX_deg:7.2f} deg\", (10, 25),\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,255), 2)\n        cv2.putText(frame, f\"AY:{angleY_deg:7.2f} deg\", (10, 50),\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,255), 2)\n\n        # ====== SI YA HAY CALIBRACI\u00d3N, MAPEAR DIRECTO A \u00c1NGULOS DE SERVOS ======\n        if base_angleX is not None and base_angleY is not None:\n            # Diferencias de \u00e1ngulo respecto a la mano neutra\n            dAX = angleX_deg - base_angleX   # roll relativo\n            dAY = angleY_deg - base_angleY   # pitch relativo\n\n            # Normalizar al rango [-1, 1] seg\u00fan el m\u00e1ximo giro que consideras\n            dAX_norm = np.clip(dAX / MAX_HAND_TILT_X, -1.0, 1.0)\n            dAY_norm = np.clip(dAY / MAX_HAND_TILT_Y, -1.0, 1.0)\n\n            # Invertir si quieres que gire al rev\u00e9s\n            if INVERT_X:\n                dAX_norm = -dAX_norm\n            if INVERT_Y:\n                dAY_norm = -dAY_norm\n\n            # Offset en grados de servo\n            servo_off_X = dAX_norm * MAX_SERVO_OFFSET_X\n            servo_off_Y = dAY_norm * MAX_SERVO_OFFSET_Y\n\n            # \u00c1ngulos L\u00d3GICOS absolutos para cada servo\n            ang_izq  = NEUT_IZQ  - servo_off_X\n            ang_der  = NEUT_DER  + servo_off_X\n            ang_vert = NEUT_VERT - servo_off_Y\n\n            # Limitar 0..180\n            ang_izq  = int(np.clip(ang_izq,  0, 180))\n            ang_der  = int(np.clip(ang_der,  0, 180))\n            ang_vert = int(np.clip(ang_vert, 0, 180))\n\n            cv2.putText(frame, f\"IZQ:{ang_izq} DER:{ang_der} VERT:{ang_vert}\",\n                        (10, 75), cv2.FONT_HERSHEY_SIMPLEX, 0.6,\n                        (0,255,255), 2)\n\n            # Enviar al ESP32\n            if send_allowed:\n                try:\n                    cmd = f\"ANG:{ang_izq},{ang_der},{ang_vert}\\n\"\n                    sock.send(cmd.encode())\n                    # print(\"CMD -&gt;\", cmd.strip())\n                    last_cmd_time = now\n                except Exception as e:\n                    print(\"\u26a0\ufe0f Error al enviar ANG:\", e)\n        else:\n            cv2.putText(frame, \"Presiona 'c' para calibrar mano neutra y mandar ZERO\",\n                        (10, h-10), cv2.FONT_HERSHEY_SIMPLEX, 0.6,\n                        (0, 0, 255), 2)\n\n    else:\n        cv2.putText(frame, \"NO HAND\", (10, 25),\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.7,\n                    (0, 0, 255), 2)\n        # Sin mano -&gt; opcional: mandar LOST\n        if send_allowed:\n            try:\n                sock.send(b\"LOST\\n\")\n                last_cmd_time = now\n            except Exception as e:\n                print(\"\u26a0\ufe0f Error al enviar LOST:\", e)\n\n    cv2.imshow(\"Hand Angle Direct Control\", frame)\n    key = cv2.waitKey(1) &amp; 0xFF\n\n    if key == ord('q'):\n        break\n    elif key == ord('c'):\n        # Calibrar mano neutra si hay \u00e1ngulos v\u00e1lidos\n        if angleX_deg is not None and angleY_deg is not None:\n            base_angleX = angleX_deg\n            base_angleY = angleY_deg\n            print(f\"Calibrado! base_angleX={base_angleX:.2f}, base_angleY={base_angleY:.2f}\")\n        # Mandar comando ZERO para llevar servos a 180 f\u00edsicos\n        try:\n            sock.send(b\"ZERO\\n\")\n            last_cmd_time = time.time()\n            print(\"Comando ZERO enviado (servos a 180 fisico).\")\n        except Exception as e:\n            print(\"\u26a0\ufe0f Error al enviar ZERO:\", e)\n\nvideo.release()\nsock.close()\ncv2.destroyAllWindows()\n</code></pre>","text":""},{"location":"Plataforma%20PD/#5-codigo-firmware-esp32-arduino","title":"5) C\u00f3digo \u2014 Firmware ESP32 (Arduino)","text":""},{"location":"Plataforma%20PD/#include-arduinoh-include-bluetoothserialh-bluetoothserial-serialbt-buffer-para-lectura-bt-no-bloqueante-string-btbuffer-pines-de-los-servos-define-servo_izq-25-define-servo_der-15-define-servo_vert-33-pwm-const-uint32_t-freq_hz-50-const-uint8_t-res_bits-12-const-uint16_t-duty_min-205-10-ms-const-uint16_t-duty_max-410-20-ms-convierte-grados-fisicos-0180-a-duty-uint16_t-dutyfromdegint-deg-deg-constraindeg0180-return-mapdeg0180duty_minduty_max-convierte-de-angulo-logico-0180-centro-90-a-fisico-invertido-int-logicaltophysicalint-logicaldeg-logicaldeg-constrainlogicaldeg-0-180-0-logico-180-fisico-180-logico-0-fisico-return-180-logicaldeg-escribe-usando-grados-logicos-void-writeservologicalint-pin-int-logicaldeg-int-fisico-logicaltophysicallogicaldeg-ledcwritepin-dutyfromdegfisico-configurar-servo-con-angulo-logico-inicial-void-configservoint-pin-int-initiallogical-pinmodepinoutput-ledcattachpinfreq_hzres_bits-usa-el-pin-como-canal-writeservologicalpininitiallogical-rango-y-rampa-const-int-lim_min-0-const-int-lim_max-180-const-int-paso_rampa-45-tamano-de-paso-en-rampa-const-uint32_t-dt_ramp_ms-2-const-uint32_t-timeout_ms-700-estado-en-grados-logicos-int-posizq-90-int-posder-90-int-posvert-60-int-tgtizq-90-int-tgtder-90-int-tgtvert-60-uint32_t-tprevramp-0-uint32_t-tlastcmd-0-rampa-suave-hacia-el-objetivo-void-aplicarrampa-uint32_t-now-millis-ifnow-tprevramp-dt_ramp_ms-return-tprevramp-now-auto-go-int-actualint-target-ifactual-target-return-minactual-paso_rampa-target-ifactual-target-return-maxactual-paso_rampa-target-return-actual-posizq-goposizq-tgtizq-posder-goposder-tgtder-posvert-goposverttgtvert-escribimos-usando-grados-logicos-se-invierten-adentro-writeservologicalservo_izq-posizq-writeservologicalservo_der-posder-writeservologicalservo_vertposvert-parsea-angizqdervert-bool-parseangulosconst-string-msg-int-aizq-int-ader-int-avert-if-msgstartswithang-return-false-string-data-msgsubstring4-despues-de-ang-int-c1-dataindexof-if-c1-0-return-false-int-c2-dataindexof-c1-1-if-c2-0-return-false-string-sizq-datasubstring0-c1-string-sder-datasubstringc1-1-c2-string-svert-datasubstringc2-1-sizqtrim-sdertrim-sverttrim-aizq-sizqtoint-ader-sdertoint-avert-sverttoint-return-true-setup-void-setup-serialbegin115200-serialbtbeginesp32-ballplatform-configservoservo_izq-posizq-configservoservo_der-posder-configservoservo_vertposvert-serialprintlnesp32-listo-tlastcmd-millis-loop-void-loop-lectura-bluetooth-no-bloqueante-while-serialbtavailable-char-c-charserialbtread-if-c-n-tenemos-una-linea-completa-en-btbuffer-string-msg-btbuffer-btbuffer-limpiar-para-el-siguiente-mensaje-msgtrim-if-msglength-0-tlastcmd-millis-if-msg-lost-pc-perdio-manoobjetivo-centro-tgtizq-90-tgtder-90-tgtvert-60-serialprintlncomando-lost-centro-else-if-msg-zero-todos-los-servos-a-180-fisicos-0-logico-por-el-mapeo-invertido-tgtizq-0-tgtder-0-tgtvert-0-serialprintlncomando-zero-servos-180-fisico-else-int-aizq-ader-avert-if-parseangulosmsg-aizq-ader-avert-tgtizq-constrainaizq-lim_min-lim_max-tgtder-constrainader-lim_min-lim_max-tgtvert-constrainavert-lim_min-lim_max-serialprintfang-izqd-derd-vertdn-tgtizq-tgtder-tgtvert-else-serialprintcomando-desconocido-serialprintlnmsg-else-if-c-r-acumulamos-caracteres-ignorando-cr-btbuffer-c-si-pasa-mucho-tiempo-sin-recibir-comandos-vuelve-al-centro-ifmillis-tlastcmd-timeout_ms-tgtizq-90-tgtder-90-tgtvert-60-aplicarrampa-delay1","title":"<pre><code>#include &lt;Arduino.h&gt;\n#include \"BluetoothSerial.h\"\n\nBluetoothSerial SerialBT;\n\n// === Buffer para lectura BT no bloqueante ===\nString btBuffer;\n\n// === Pines de los servos ===\n#define SERVO_IZQ   25\n#define SERVO_DER   15\n#define SERVO_VERT  33\n\n// === PWM ===\nconst uint32_t FREQ_HZ = 50;\nconst uint8_t  RES_BITS = 12;\nconst uint16_t DUTY_MIN = 205;   // ~1.0 ms\nconst uint16_t DUTY_MAX = 410;   // ~2.0 ms\n\n// Convierte grados f\u00edsicos 0..180 a duty\nuint16_t dutyFromDeg(int deg){\n  deg = constrain(deg,0,180);\n  return map(deg,0,180,DUTY_MIN,DUTY_MAX);\n}\n\n// Convierte de \u00e1ngulo l\u00f3gico (0..180, centro 90) a f\u00edsico (invertido)\nint logicalToPhysical(int logicalDeg){\n  logicalDeg = constrain(logicalDeg, 0, 180);\n  // 0 l\u00f3gico \u2192 180 f\u00edsico, 180 l\u00f3gico \u2192 0 f\u00edsico\n  return 180 - logicalDeg;\n}\n\n// Escribe usando grados l\u00f3gicos\nvoid writeServoLogical(int pin, int logicalDeg){\n  int fisico = logicalToPhysical(logicalDeg);\n  ledcWrite(pin, dutyFromDeg(fisico));\n}\n\n// Configurar servo con \u00e1ngulo l\u00f3gico inicial\nvoid configServo(int pin, int initialLogical){\n  pinMode(pin,OUTPUT);\n  ledcAttach(pin,FREQ_HZ,RES_BITS);   // usa el pin como canal\n  writeServoLogical(pin,initialLogical);\n}\n\n// === Rango y rampa ===\nconst int LIM_MIN = 0;\nconst int LIM_MAX = 180;\nconst int PASO_RAMPA = 45;          // tama\u00f1o de paso en rampa\nconst uint32_t DT_RAMP_MS = 2;\nconst uint32_t TIMEOUT_MS = 700;\n\n// Estado en grados L\u00d3GICOS\nint posIzq = 90;\nint posDer = 90;\nint posVert= 60;\n\nint tgtIzq = 90;\nint tgtDer = 90;\nint tgtVert= 60;\n\nuint32_t tPrevRamp = 0;\nuint32_t tLastCmd  = 0;\n\n// Rampa suave hacia el objetivo\nvoid aplicarRampa(){\n  uint32_t now = millis();\n  if(now - tPrevRamp &lt; DT_RAMP_MS) return;\n  tPrevRamp = now;\n\n  auto go = [&amp;](int actual,int target){\n    if(actual &lt; target) return min(actual + PASO_RAMPA, target);\n    if(actual &gt; target) return max(actual - PASO_RAMPA, target);\n    return actual;\n  };\n\n  posIzq = go(posIzq, tgtIzq);\n  posDer = go(posDer, tgtDer);\n  posVert= go(posVert,tgtVert);\n\n  // Escribimos usando grados L\u00d3GICOS, se invierten adentro\n  writeServoLogical(SERVO_IZQ, posIzq);\n  writeServoLogical(SERVO_DER, posDer);\n  writeServoLogical(SERVO_VERT,posVert);\n}\n\n// Parsea \"ANG:izq,der,vert\"\nbool parseAngulos(const String &amp;msg, int &amp;aIzq, int &amp;aDer, int &amp;aVert){\n  if (!msg.startsWith(\"ANG:\")) return false;\n  String data = msg.substring(4);  // despu\u00e9s de \"ANG:\"\n\n  int c1 = data.indexOf(',');\n  if (c1 &lt; 0) return false;\n  int c2 = data.indexOf(',', c1 + 1);\n  if (c2 &lt; 0) return false;\n\n  String sIzq  = data.substring(0, c1);\n  String sDer  = data.substring(c1 + 1, c2);\n  String sVert = data.substring(c2 + 1);\n\n  sIzq.trim();\n  sDer.trim();\n  sVert.trim();\n\n  aIzq  = sIzq.toInt();\n  aDer  = sDer.toInt();\n  aVert = sVert.toInt();\n\n  return true;\n}\n\n// ======== SETUP ========\nvoid setup(){\n  Serial.begin(115200);\n  SerialBT.begin(\"ESP32-BallPlatform\");\n\n  configServo(SERVO_IZQ, posIzq);\n  configServo(SERVO_DER, posDer);\n  configServo(SERVO_VERT,posVert);\n\n  Serial.println(\"ESP32 listo\");\n  tLastCmd = millis();\n}\n\n// ======== LOOP ========\nvoid loop(){\n\n  // --- Lectura Bluetooth no bloqueante ---\n  while (SerialBT.available()) {\n    char c = (char)SerialBT.read();\n\n    if (c == '\\n') {\n      // Tenemos una l\u00ednea completa en btBuffer\n      String msg = btBuffer;\n      btBuffer = \"\";        // limpiar para el siguiente mensaje\n\n      msg.trim();\n      if (msg.length() &gt; 0) {\n        tLastCmd = millis();\n\n        if (msg == \"LOST\") {\n          // PC perdi\u00f3 mano/objetivo \u2192 \"centro\"\n          tgtIzq  = 90;\n          tgtDer  = 90;\n          tgtVert = 60;\n          Serial.println(\"Comando LOST: centro.\");\n\n        } else if (msg == \"ZERO\") {\n          // \ud83d\udd39 TODOS los servos a 180 f\u00edsicos\n          //    \u21d2 0 l\u00f3gico por el mapeo invertido\n          tgtIzq  = 0;\n          tgtDer  = 0;\n          tgtVert = 0;\n          Serial.println(\"Comando ZERO: servos \u2192 180\u00b0 fisico\");\n\n        } else {\n          int aIzq, aDer, aVert;\n          if (parseAngulos(msg, aIzq, aDer, aVert)) {\n            tgtIzq  = constrain(aIzq,  LIM_MIN, LIM_MAX);\n            tgtDer  = constrain(aDer,  LIM_MIN, LIM_MAX);\n            tgtVert = constrain(aVert, LIM_MIN, LIM_MAX);\n            Serial.printf(\"ANG -&gt; IZQ:%d DER:%d VERT:%d\\n\", tgtIzq, tgtDer, tgtVert);\n          } else {\n            Serial.print(\"Comando desconocido: \");\n            Serial.println(msg);\n          }\n        }\n      }\n    } else if (c != '\\r') {\n      // Acumulamos caracteres, ignorando CR\n      btBuffer += c;\n    }\n  }\n\n  // Si pasa mucho tiempo sin recibir comandos, vuelve al centro\n  if(millis() - tLastCmd &gt; TIMEOUT_MS){\n    tgtIzq = 90;\n    tgtDer = 90;\n    tgtVert= 60;\n  }\n\n  aplicarRampa();\n  delay(1);\n}\n</code></pre>","text":""},{"location":"Plataforma%20PD/#6-codigo-control-pd-de-la-pelota-python","title":"6) C\u00f3digo \u2014 Control PD de la Pelota (Python)","text":""},{"location":"Plataforma%20PD/#import-cv2-import-numpy-as-np-import-bluetooth-import-time-bluetooth-device_mac-f024f90c4cde-misma-mac-del-esp32-port-1-parametros-servos-neut_izq-90-neut_der-90-neut_vert-60-modo-test-para-exagerar-el-movimiento-test_mode-true-cambia-a-false-cuando-ya-quieras-algo-mas-fino-if-test_mode-mucho-mas-movimiento-de-servos-max_servo_offset_x-500-antes-40-max_servo_offset_y-350-antes-30-control-mas-agresivo-y-sin-derivada-mas-facil-ver-el-sentido-kpx-20-kdx-00-kpy-20-kdy-00-else-valores-mas-tranquilos-para-uso-normal-max_servo_offset_x-400-max_servo_offset_y-300-kpx-08-kdx-02-kpy-08-kdy-02-flags-de-orientacion-los-vas-cambiando-en-vivo-invert_x-false-lo-puedes-cambiar-con-la-tecla-x-invert_y-false-lo-puedes-cambiar-con-la-tecla-y-swap_axes-false-si-true-intercambia-x-y-tecla-s-alpha-08-filtro-para-derivada-min_dt_cmd-0015-15-ms-66-hz-max-last_cmd_time-00-last_time-timetime-last_errx-00-last_erry-00-dxf-00-dyf-00-centro-calibrado-de-la-plataforma-en-pixeles-de-la-imagen-centerx-none-centery-none-ultima-posicion-conocida-de-la-pelota-para-la-tecla-b-last_ball_x-none-last_ball_y-none-conexion-bluetooth-sock-none-printintentando-conectar-al-esp32-por-bluetooth-device_mac-while-true-try-sock-bluetoothbluetoothsocket-socksettimeout10-sockconnectdevice_mac-port-print-conectado-al-esp32-break-except-exception-as-e-printerror-de-conexion-reintentando-e-timesleep1-camara-la-que-ve-la-plataforma-cambia-1-a-0-si-tu-otra-camara-es-la-que-ve-la-plataforma-video-cv2videocapture1-rango-hsv-para-la-pelota-ejemplo-naranja-lower-nparray10-150-120-npuint8-upper-nparray25-255-255-npuint8-kernel-cv2getstructuringelementcv2morph_ellipse-3-3-while-true-ok-frame-videoread-if-not-ok-break-si-la-camara-te-da-la-imagen-al-reves-y-quieres-voltearla-frame-cv2flipframe-1-h-w-frameshape2-si-aun-no-hay-centro-calibrado-por-defecto-usa-el-centro-de-la-imagen-if-centerx-is-none-or-centery-is-none-centerx-w-2-centery-h-2-now-timetime-dt-now-last_time-if-now-last_time-else-001-send_allowed-now-last_cmd_time-min_dt_cmd-deteccion-de-pelota-por-color-hsv-cv2cvtcolorframe-cv2color_bgr2hsv-mask-cv2inrangehsv-lower-upper-mask-cv2erodemask-kernel-iterations2-mask-cv2dilatemask-kernel-iterations2-contornos-_-cv2findcontoursmask-cv2retr_external-cv2chain_approx_simple-tiene_pelota-false-if-lencontornos-0-c-maxcontornos-keycv2contourarea-x-y-radio-cv2minenclosingcirclec-if-radio-5-umbral-minimo-para-ruido-tiene_pelota-true-x-intx-y-inty-radio-intradio-guardamos-ultima-posicion-de-la-pelota-last_ball_x-x-last_ball_y-y-dibujar-pelota-cv2circleframe-x-y-radio-255-0-0-2-cv2circleframe-x-y-3-255-0-0-1-dibujar-lineas-del-centro-calibrado-cx-intcenterx-cy-intcentery-cv2lineframe-cx-0-cx-h-0-255-255-1-cv2lineframe-0-cy-w-cy-0-255-255-1-cv2circleframe-cx-cy-5-0-255-0-1-centro-calibrado-errores-normalizados-respecto-al-centro-calibrado-errx_img-x-cx-w-2-derecha-izquierda-erry_img-y-cy-h-2-abajo-arriba-posible-intercambio-de-ejes-if-swap_axes-errx_raw-erry_img-erry_raw-errx_img-else-errx_raw-errx_img-erry_raw-erry_img-mostrar-errores-crudos-para-debug-cv2puttextframe-fex_rawerrx_raw2f-ey_rawerry_raw2f-10-25-cv2font_hershey_simplex-06-255-255-255-2-control-pd-derx-errx_raw-last_errx-dt-dery-erry_raw-last_erry-dt-dxf-alpha-dxf-1-alpha-derx-dyf-alpha-dyf-1-alpha-dery-ux-kpx-errx_raw-kdx-dxf-uy-kpy-erry_raw-kdy-dyf-limitamos-ux-uy-a-11-ux-floatnpclipux-10-10-uy-floatnpclipuy-10-10-invertir-si-hace-falta-lo-cambias-en-vivo-con-x-y-y-if-invert_x-ux-ux-if-invert_y-uy-uy-offset-de-servos-en-grados-servo_off_x-ux-max_servo_offset_x-servo_off_y-uy-max_servo_offset_y-angulos-logicos-absolutos-ang_izq-neut_izq-servo_off_x-ang_der-neut_der-servo_off_x-ang_vert-neut_vert-servo_off_y-limitar-a-0180-ang_izq-intnpclipang_izq-0-180-ang_der-intnpclipang_der-0-180-ang_vert-intnpclipang_vert-0-180-cv2puttextframe-fizqang_izq-derang_der-vertang_vert-10-50-cv2font_hershey_simplex-06-0-255-255-2-enviar-comando-ang-if-send_allowed-try-cmd-fangang_izqang_derang_vertn-socksendcmdencode-printcmd-cmdstrip-last_cmd_time-now-except-exception-as-e-print-error-al-enviar-ang-e-last_errx-errx_raw-last_erry-erry_raw-last_time-now-if-not-tiene_pelota-cv2puttextframe-pelota-no-detectada-10-25-cv2font_hershey_simplex-07-0-0-255-2-opcional-si-pierdes-la-pelota-manda-lost-para-nivelar-if-send_allowed-try-socksendblostn-last_cmd_time-now-except-exception-as-e-print-error-al-enviar-lost-e-mostrar-estado-de-flags-status-finvxinvert_x-invyinvert_y-swapswap_axes-testtest_mode-cv2puttextframe-status-10-h-10-cv2font_hershey_simplex-06-0-255-0-2-cv2imshowball-balancing-control-frame-cv2imshowmascara-mask-key-cv2waitkey1-0xff-if-key-ordq-break-elif-key-ordc-tecla-c-para-nivelar-manualmente-centro-por-firmware-try-socksendblostn-last_cmd_time-timetime-printcomando-lost-enviado-plataforma-al-centro-except-exception-as-e-print-error-al-enviar-lost-e-elif-key-ordx-invert_x-not-invert_x-printinvert_x-invert_x-elif-key-ordy-invert_y-not-invert_y-printinvert_y-invert_y-elif-key-ords-swap_axes-not-swap_axes-printswap_axes-swap_axes-elif-key-ordb-calibrar-centro-con-la-pelota-en-el-centro-fisico-if-last_ball_x-is-not-none-and-last_ball_y-is-not-none-centerx-last_ball_x-centery-last_ball_y-printfcentro-calibrado-en-centerx-centery-videorelease-sockclose-cv2destroyallwindows","title":"<pre><code>import cv2\nimport numpy as np\nimport bluetooth\nimport time\n\n# ========= BLUETOOTH =========\ndevice_mac = \"F0:24:F9:0C:4C:DE\"   # MISMA MAC DEL ESP32\nport = 1\n\n# ========= PAR\u00c1METROS SERVOS =========\nNEUT_IZQ  = 90\nNEUT_DER  = 90\nNEUT_VERT = 60\n\n# ----- MODO TEST (para exagerar el movimiento) -----\nTEST_MODE = True   # Cambia a False cuando ya quieras algo m\u00e1s fino\n\nif TEST_MODE:\n    # Mucho m\u00e1s movimiento de servos\n    MAX_SERVO_OFFSET_X = 50.0   # antes 40\n    MAX_SERVO_OFFSET_Y = 35.0   # antes 30\n\n    # Control m\u00e1s agresivo y SIN derivada (m\u00e1s f\u00e1cil ver el sentido)\n    KpX = 2.0\n    KdX = 0.0\n\n    KpY = 2.0\n    KdY = 0.0\nelse:\n    # Valores m\u00e1s tranquilos para uso normal\n    MAX_SERVO_OFFSET_X = 40.0\n    MAX_SERVO_OFFSET_Y = 30.0\n\n    KpX = 0.8\n    KdX = 0.2\n\n    KpY = 0.8\n    KdY = 0.2\n\n# ====== FLAGS DE ORIENTACI\u00d3N (LOS VAS CAMBIANDO EN VIVO) ======\nINVERT_X = False   # lo puedes cambiar con la tecla 'x'\nINVERT_Y = False   # lo puedes cambiar con la tecla 'y'\nSWAP_AXES = False  # si True, intercambia X&lt;-&gt;Y (tecla 's')\n\nalpha = 0.8          # filtro para derivada\nMIN_DT_CMD = 0.015   # 15 ms (~66 Hz m\u00e1x)\n\nlast_cmd_time = 0.0\nlast_time = time.time()\n\nlast_errx = 0.0\nlast_erry = 0.0\ndxf = 0.0\ndyf = 0.0\n\n# Centro calibrado de la plataforma (en p\u00edxeles de la imagen)\ncenterX = None\ncenterY = None\n\n# \u00daltima posici\u00f3n conocida de la pelota (para la tecla 'b')\nlast_ball_x = None\nlast_ball_y = None\n\n# ========= CONEXI\u00d3N BLUETOOTH =========\nsock = None\nprint(\"Intentando conectar al ESP32 por Bluetooth...\", device_mac)\nwhile True:\n    try:\n        sock = bluetooth.BluetoothSocket()\n        sock.settimeout(10)\n        sock.connect((device_mac, port))\n        print(\"\u2705 Conectado al ESP32!\")\n        break\n    except Exception as e:\n        print(\"Error de conexi\u00f3n, reintentando:\", e)\n        time.sleep(1)\n\n# ========= C\u00c1MARA (LA QUE VE LA PLATAFORMA) =========\n# Cambia 1 a 0 si tu otra c\u00e1mara es la que ve la plataforma\nvideo = cv2.VideoCapture(1)\n\n# ========= RANGO HSV PARA LA PELOTA (EJEMPLO: NARANJA) =========\nLOWER = np.array([10, 150, 120], np.uint8)\nUPPER = np.array([25, 255, 255], np.uint8)\n\nkernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))\n\nwhile True:\n    ok, frame = video.read()\n    if not ok:\n        break\n\n    # Si la c\u00e1mara te da la imagen al rev\u00e9s y quieres voltearla:\n    # frame = cv2.flip(frame, 1)\n\n    h, w = frame.shape[:2]\n\n    # Si a\u00fan no hay centro calibrado, por defecto usa el centro de la imagen\n    if centerX is None or centerY is None:\n        centerX = w // 2\n        centerY = h // 2\n\n    now = time.time()\n    dt = now - last_time if now &gt; last_time else 0.01\n    send_allowed = (now - last_cmd_time) &gt;= MIN_DT_CMD\n\n    # --- Detecci\u00f3n de pelota por color ---\n    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n    mask = cv2.inRange(hsv, LOWER, UPPER)\n    mask = cv2.erode(mask, kernel, iterations=2)\n    mask = cv2.dilate(mask, kernel, iterations=2)\n\n    contornos, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n    tiene_pelota = False\n\n    if len(contornos) &gt; 0:\n        c = max(contornos, key=cv2.contourArea)\n        (x, y), radio = cv2.minEnclosingCircle(c)\n\n        if radio &gt; 5:  # umbral m\u00ednimo para ruido\n            tiene_pelota = True\n\n            x = int(x)\n            y = int(y)\n            radio = int(radio)\n\n            # Guardamos \u00faltima posici\u00f3n de la pelota\n            last_ball_x = x\n            last_ball_y = y\n\n            # Dibujar pelota\n            cv2.circle(frame, (x, y), radio, (255, 0, 0), 2)\n            cv2.circle(frame, (x, y), 3, (255, 0, 0), -1)\n\n            # Dibujar l\u00edneas del centro calibrado\n            cx = int(centerX)\n            cy = int(centerY)\n            cv2.line(frame, (cx, 0), (cx, h), (0, 255, 255), 1)\n            cv2.line(frame, (0, cy), (w, cy), (0, 255, 255), 1)\n            cv2.circle(frame, (cx, cy), 5, (0, 255, 0), -1)  # centro calibrado\n\n            # Errores normalizados respecto al centro calibrado\n            errx_img = (x - cx) / (w / 2)   # derecha +, izquierda -\n            erry_img = (y - cy) / (h / 2)   # abajo +, arriba -\n\n            # Posible intercambio de ejes\n            if SWAP_AXES:\n                errx_raw = erry_img\n                erry_raw = errx_img\n            else:\n                errx_raw = errx_img\n                erry_raw = erry_img\n\n            # Mostrar errores crudos para debug\n            cv2.putText(frame, f\"Ex_raw:{errx_raw:+.2f} Ey_raw:{erry_raw:+.2f}\",\n                        (10, 25), cv2.FONT_HERSHEY_SIMPLEX, 0.6,\n                        (255, 255, 255), 2)\n\n            # --- Control PD ---\n            derx = (errx_raw - last_errx) / dt\n            dery = (erry_raw - last_erry) / dt\n\n            dxf = alpha * dxf + (1 - alpha) * derx\n            dyf = alpha * dyf + (1 - alpha) * dery\n\n            uX = KpX * errx_raw + KdX * dxf\n            uY = KpY * erry_raw + KdY * dyf\n\n            # Limitamos uX, uY a [-1,1]\n            uX = float(np.clip(uX, -1.0, 1.0))\n            uY = float(np.clip(uY, -1.0, 1.0))\n\n            # Invertir si hace falta (lo cambias en vivo con 'x' y 'y')\n            if INVERT_X:\n                uX = -uX\n            if INVERT_Y:\n                uY = -uY\n\n            # Offset de servos en grados\n            servo_off_X = uX * MAX_SERVO_OFFSET_X\n            servo_off_Y = uY * MAX_SERVO_OFFSET_Y\n\n            # \u00c1ngulos l\u00f3gicos absolutos\n            ang_izq  = NEUT_IZQ  - servo_off_X\n            ang_der  = NEUT_DER  + servo_off_X\n            ang_vert = NEUT_VERT - servo_off_Y\n\n            # Limitar a 0..180\n            ang_izq  = int(np.clip(ang_izq,  0, 180))\n            ang_der  = int(np.clip(ang_der,  0, 180))\n            ang_vert = int(np.clip(ang_vert, 0, 180))\n\n            cv2.putText(frame,\n                        f\"IZQ:{ang_izq} DER:{ang_der} VERT:{ang_vert}\",\n                        (10, 50), cv2.FONT_HERSHEY_SIMPLEX, 0.6,\n                        (0, 255, 255), 2)\n\n            # --- Enviar comando ANG: ---\n            if send_allowed:\n                try:\n                    cmd = f\"ANG:{ang_izq},{ang_der},{ang_vert}\\n\"\n                    sock.send(cmd.encode())\n                    # print(\"CMD -&gt;\", cmd.strip())\n                    last_cmd_time = now\n                except Exception as e:\n                    print(\"\u26a0\ufe0f Error al enviar ANG:\", e)\n\n            last_errx = errx_raw\n            last_erry = erry_raw\n            last_time = now\n\n    if not tiene_pelota:\n        cv2.putText(frame, \"PELOTA NO DETECTADA\", (10, 25),\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.7,\n                    (0, 0, 255), 2)\n        # Opcional: si pierdes la pelota, manda LOST para nivelar\n        if send_allowed:\n            try:\n                sock.send(b\"LOST\\n\")\n                last_cmd_time = now\n            except Exception as e:\n                print(\"\u26a0\ufe0f Error al enviar LOST:\", e)\n\n    # Mostrar estado de flags\n    status = f\"invX:{INVERT_X}  invY:{INVERT_Y}  swap:{SWAP_AXES}  TEST:{TEST_MODE}\"\n    cv2.putText(frame, status, (10, h - 10),\n                cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)\n\n    cv2.imshow(\"Ball Balancing Control\", frame)\n    cv2.imshow(\"Mascara\", mask)\n\n    key = cv2.waitKey(1) &amp; 0xFF\n    if key == ord('q'):\n        break\n    elif key == ord('c'):\n        # Tecla 'c' para nivelar manualmente (centro por firmware)\n        try:\n            sock.send(b\"LOST\\n\")\n            last_cmd_time = time.time()\n            print(\"Comando LOST enviado (plataforma al centro).\")\n        except Exception as e:\n            print(\"\u26a0\ufe0f Error al enviar LOST:\", e)\n    elif key == ord('x'):\n        INVERT_X = not INVERT_X\n        print(\"INVERT_X -&gt;\", INVERT_X)\n    elif key == ord('y'):\n        INVERT_Y = not INVERT_Y\n        print(\"INVERT_Y -&gt;\", INVERT_Y)\n    elif key == ord('s'):\n        SWAP_AXES = not SWAP_AXES\n        print(\"SWAP_AXES -&gt;\", SWAP_AXES)\n    elif key == ord('b'):\n        # Calibrar centro con la pelota en el centro f\u00edsico\n        if last_ball_x is not None and last_ball_y is not None:\n            centerX = last_ball_x\n            centerY = last_ball_y\n            print(f\"Centro calibrado en ({centerX}, {centerY})\")\n\nvideo.release()\nsock.close()\ncv2.destroyAllWindows()\n</code></pre>","text":""},{"location":"Plataforma%20PD/#7-codigo-firmware-esp32-arduino","title":"7) C\u00f3digo \u2014 Firmware ESP32 (Arduino)","text":""},{"location":"Plataforma%20PD/#include-arduinoh-include-bluetoothserialh-bluetoothserial-serialbt-buffer-para-lectura-bt-no-bloqueante-string-btbuffer-pines-de-los-servos-define-servo_izq-25-define-servo_der-15-define-servo_vert-33-pwm-const-uint32_t-freq_hz-50-const-uint8_t-res_bits-12-const-uint16_t-duty_min-205-10-ms-const-uint16_t-duty_max-410-20-ms-convierte-grados-fisicos-0180-a-duty-uint16_t-dutyfromdegint-deg-deg-constraindeg0180-return-mapdeg0180duty_minduty_max-convierte-de-angulo-logico-0180-centro-90-a-fisico-invertido-int-logicaltophysicalint-logicaldeg-logicaldeg-constrainlogicaldeg-0-180-0-logico-180-fisico-180-logico-0-fisico-return-180-logicaldeg-escribe-usando-grados-logicos-void-writeservologicalint-pin-int-logicaldeg-int-fisico-logicaltophysicallogicaldeg-ledcwritepin-dutyfromdegfisico-configurar-servo-con-angulo-logico-inicial-void-configservoint-pin-int-initiallogical-pinmodepinoutput-ledcattachpinfreq_hzres_bits-usa-el-pin-como-canal-writeservologicalpininitiallogical-rango-y-rampa-const-int-lim_min-0-const-int-lim_max-180-const-int-paso_rampa-45-tamano-de-paso-en-rampa-const-uint32_t-dt_ramp_ms-2-const-uint32_t-timeout_ms-700-estado-en-grados-logicos-int-posizq-90-int-posder-90-int-posvert-60-int-tgtizq-90-int-tgtder-90-int-tgtvert-60-uint32_t-tprevramp-0-uint32_t-tlastcmd-0-rampa-suave-hacia-el-objetivo-void-aplicarrampa-uint32_t-now-millis-ifnow-tprevramp-dt_ramp_ms-return-tprevramp-now-auto-go-int-actualint-target-ifactual-target-return-minactual-paso_rampa-target-ifactual-target-return-maxactual-paso_rampa-target-return-actual-posizq-goposizq-tgtizq-posder-goposder-tgtder-posvert-goposverttgtvert-escribimos-usando-grados-logicos-se-invierten-adentro-writeservologicalservo_izq-posizq-writeservologicalservo_der-posder-writeservologicalservo_vertposvert-parsea-angizqdervert-bool-parseangulosconst-string-msg-int-aizq-int-ader-int-avert-if-msgstartswithang-return-false-string-data-msgsubstring4-despues-de-ang-int-c1-dataindexof-if-c1-0-return-false-int-c2-dataindexof-c1-1-if-c2-0-return-false-string-sizq-datasubstring0-c1-string-sder-datasubstringc1-1-c2-string-svert-datasubstringc2-1-sizqtrim-sdertrim-sverttrim-aizq-sizqtoint-ader-sdertoint-avert-sverttoint-return-true-setup-void-setup-serialbegin115200-serialbtbeginesp32-ballplatform-configservoservo_izq-posizq-configservoservo_der-posder-configservoservo_vertposvert-serialprintlnesp32-listo-tlastcmd-millis-loop-void-loop-lectura-bluetooth-no-bloqueante-while-serialbtavailable-char-c-charserialbtread-if-c-n-tenemos-una-linea-completa-en-btbuffer-string-msg-btbuffer-btbuffer-limpiar-para-el-siguiente-mensaje-msgtrim-if-msglength-0-tlastcmd-millis-if-msg-lost-pc-perdio-manoobjetivo-centro-tgtizq-90-tgtder-90-tgtvert-60-serialprintlncomando-lost-centro-else-if-msg-zero-todos-los-servos-a-180-fisicos-0-logico-por-el-mapeo-invertido-tgtizq-0-tgtder-0-tgtvert-0-serialprintlncomando-zero-servos-180-fisico-else-int-aizq-ader-avert-if-parseangulosmsg-aizq-ader-avert-tgtizq-constrainaizq-lim_min-lim_max-tgtder-constrainader-lim_min-lim_max-tgtvert-constrainavert-lim_min-lim_max-serialprintfang-izqd-derd-vertdn-tgtizq-tgtder-tgtvert-else-serialprintcomando-desconocido-serialprintlnmsg-else-if-c-r-acumulamos-caracteres-ignorando-cr-btbuffer-c-si-pasa-mucho-tiempo-sin-recibir-comandos-vuelve-al-centro-ifmillis-tlastcmd-timeout_ms-tgtizq-90-tgtder-90-tgtvert-60-aplicarrampa-delay1_1","title":"<pre><code>#include &lt;Arduino.h&gt;\n#include \"BluetoothSerial.h\"\n\nBluetoothSerial SerialBT;\n\n// === Buffer para lectura BT no bloqueante ===\nString btBuffer;\n\n// === Pines de los servos ===\n#define SERVO_IZQ   25\n#define SERVO_DER   15\n#define SERVO_VERT  33\n\n// === PWM ===\nconst uint32_t FREQ_HZ = 50;\nconst uint8_t  RES_BITS = 12;\nconst uint16_t DUTY_MIN = 205;   // ~1.0 ms\nconst uint16_t DUTY_MAX = 410;   // ~2.0 ms\n\n// Convierte grados f\u00edsicos 0..180 a duty\nuint16_t dutyFromDeg(int deg){\n  deg = constrain(deg,0,180);\n  return map(deg,0,180,DUTY_MIN,DUTY_MAX);\n}\n\n// Convierte de \u00e1ngulo l\u00f3gico (0..180, centro 90) a f\u00edsico (invertido)\nint logicalToPhysical(int logicalDeg){\n  logicalDeg = constrain(logicalDeg, 0, 180);\n  // 0 l\u00f3gico \u2192 180 f\u00edsico, 180 l\u00f3gico \u2192 0 f\u00edsico\n  return 180 - logicalDeg;\n}\n\n// Escribe usando grados l\u00f3gicos\nvoid writeServoLogical(int pin, int logicalDeg){\n  int fisico = logicalToPhysical(logicalDeg);\n  ledcWrite(pin, dutyFromDeg(fisico));\n}\n\n// Configurar servo con \u00e1ngulo l\u00f3gico inicial\nvoid configServo(int pin, int initialLogical){\n  pinMode(pin,OUTPUT);\n  ledcAttach(pin,FREQ_HZ,RES_BITS);   // usa el pin como canal\n  writeServoLogical(pin,initialLogical);\n}\n\n// === Rango y rampa ===\nconst int LIM_MIN = 0;\nconst int LIM_MAX = 180;\nconst int PASO_RAMPA = 45;          // tama\u00f1o de paso en rampa\nconst uint32_t DT_RAMP_MS = 2;\nconst uint32_t TIMEOUT_MS = 700;\n\n// Estado en grados L\u00d3GICOS\nint posIzq = 90;\nint posDer = 90;\nint posVert= 60;\n\nint tgtIzq = 90;\nint tgtDer = 90;\nint tgtVert= 60;\n\nuint32_t tPrevRamp = 0;\nuint32_t tLastCmd  = 0;\n\n// Rampa suave hacia el objetivo\nvoid aplicarRampa(){\n  uint32_t now = millis();\n  if(now - tPrevRamp &lt; DT_RAMP_MS) return;\n  tPrevRamp = now;\n\n  auto go = [&amp;](int actual,int target){\n    if(actual &lt; target) return min(actual + PASO_RAMPA, target);\n    if(actual &gt; target) return max(actual - PASO_RAMPA, target);\n    return actual;\n  };\n\n  posIzq = go(posIzq, tgtIzq);\n  posDer = go(posDer, tgtDer);\n  posVert= go(posVert,tgtVert);\n\n  // Escribimos usando grados L\u00d3GICOS, se invierten adentro\n  writeServoLogical(SERVO_IZQ, posIzq);\n  writeServoLogical(SERVO_DER, posDer);\n  writeServoLogical(SERVO_VERT,posVert);\n}\n\n// Parsea \"ANG:izq,der,vert\"\nbool parseAngulos(const String &amp;msg, int &amp;aIzq, int &amp;aDer, int &amp;aVert){\n  if (!msg.startsWith(\"ANG:\")) return false;\n  String data = msg.substring(4);  // despu\u00e9s de \"ANG:\"\n\n  int c1 = data.indexOf(',');\n  if (c1 &lt; 0) return false;\n  int c2 = data.indexOf(',', c1 + 1);\n  if (c2 &lt; 0) return false;\n\n  String sIzq  = data.substring(0, c1);\n  String sDer  = data.substring(c1 + 1, c2);\n  String sVert = data.substring(c2 + 1);\n\n  sIzq.trim();\n  sDer.trim();\n  sVert.trim();\n\n  aIzq  = sIzq.toInt();\n  aDer  = sDer.toInt();\n  aVert = sVert.toInt();\n\n  return true;\n}\n\n// ======== SETUP ========\nvoid setup(){\n  Serial.begin(115200);\n  SerialBT.begin(\"ESP32-BallPlatform\");\n\n  configServo(SERVO_IZQ, posIzq);\n  configServo(SERVO_DER, posDer);\n  configServo(SERVO_VERT,posVert);\n\n  Serial.println(\"ESP32 listo\");\n  tLastCmd = millis();\n}\n\n// ======== LOOP ========\nvoid loop(){\n\n  // --- Lectura Bluetooth no bloqueante ---\n  while (SerialBT.available()) {\n    char c = (char)SerialBT.read();\n\n    if (c == '\\n') {\n      // Tenemos una l\u00ednea completa en btBuffer\n      String msg = btBuffer;\n      btBuffer = \"\";        // limpiar para el siguiente mensaje\n\n      msg.trim();\n      if (msg.length() &gt; 0) {\n        tLastCmd = millis();\n\n        if (msg == \"LOST\") {\n          // PC perdi\u00f3 mano/objetivo \u2192 \"centro\"\n          tgtIzq  = 90;\n          tgtDer  = 90;\n          tgtVert = 60;\n          Serial.println(\"Comando LOST: centro.\");\n\n        } else if (msg == \"ZERO\") {\n          // \ud83d\udd39 TODOS los servos a 180 f\u00edsicos\n          //    \u21d2 0 l\u00f3gico por el mapeo invertido\n          tgtIzq  = 0;\n          tgtDer  = 0;\n          tgtVert = 0;\n          Serial.println(\"Comando ZERO: servos \u2192 180\u00b0 fisico\");\n\n        } else {\n          int aIzq, aDer, aVert;\n          if (parseAngulos(msg, aIzq, aDer, aVert)) {\n            tgtIzq  = constrain(aIzq,  LIM_MIN, LIM_MAX);\n            tgtDer  = constrain(aDer,  LIM_MIN, LIM_MAX);\n            tgtVert = constrain(aVert, LIM_MIN, LIM_MAX);\n            Serial.printf(\"ANG -&gt; IZQ:%d DER:%d VERT:%d\\n\", tgtIzq, tgtDer, tgtVert);\n          } else {\n            Serial.print(\"Comando desconocido: \");\n            Serial.println(msg);\n          }\n        }\n      }\n    } else if (c != '\\r') {\n      // Acumulamos caracteres, ignorando CR\n      btBuffer += c;\n    }\n  }\n\n  // Si pasa mucho tiempo sin recibir comandos, vuelve al centro\n  if(millis() - tLastCmd &gt; TIMEOUT_MS){\n    tgtIzq = 90;\n    tgtDer = 90;\n    tgtVert= 60;\n  }\n\n  aplicarRampa();\n  delay(1);\n}\n</code></pre>","text":""},{"location":"Plataforma%20PD/#7-descripcion-de-funcionamiento","title":"7) Descripci\u00f3n de Funcionamiento","text":"<ul> <li>En el modo Control por Mano:</li> <li>La c\u00e1mara captura la imagen de la mano y se calculan \u00e1ngulos de orientaci\u00f3n (roll y pitch).</li> <li>Dichos \u00e1ngulos se convierten en valores l\u00f3gicos (0\u2013180\u00b0) para los servomotores.</li> <li>Se env\u00edan comandos por Bluetooth con el formato <code>ANG:izq,der,vert</code>, adem\u00e1s de comandos auxiliares como <code>ZERO</code> para referencia y <code>LOST</code> para regresar la plataforma a posici\u00f3n neutral.</li> <li> <p>Los servomotores ejecutan los cambios de \u00e1ngulo con una rampa de transici\u00f3n para evitar movimientos bruscos.</p> </li> <li> <p>En el modo Control PD por C\u00e1mara Frontal:</p> </li> <li>La c\u00e1mara identifica la posici\u00f3n de la pelota mediante segmentaci\u00f3n por color.</li> <li>Con la diferencia entre la posici\u00f3n deseada y la real, se calcula un error en los ejes X y Y.</li> <li>Se aplica un controlador PD, donde:<ul> <li><code>Kp</code> controla la correcci\u00f3n proporcional.</li> <li><code>Kd</code> filtra la derivada para mejorar estabilidad.</li> </ul> </li> <li>Los valores calculados se convierten a grados y se env\u00edan al ESP32 con el mismo formato de comando <code>ANG</code>.</li> <li>El firmware interpola suavemente los movimientos para mejorar la precisi\u00f3n.</li> </ul>"},{"location":"Plataforma%20PD/#8-resultados-obtenidos","title":"8) Resultados Obtenidos","text":"<ul> <li>El control PD permiti\u00f3 corregir la posici\u00f3n de la pelota sobre la plataforma de manera eficiente.</li> <li>Ajustar los valores de ganancia fue clave para lograr una estabilizaci\u00f3n m\u00e1s r\u00e1pida.</li> <li>Se comprob\u00f3 que ampliar la distancia entre los servomotores mejor\u00f3 el rango y la sensibilidad del control mec\u00e1nico.</li> <li>La interpolaci\u00f3n por rampa minimiz\u00f3 vibraciones y aument\u00f3 la estabilidad visual y mec\u00e1nica del sistema.</li> </ul>"},{"location":"Plataforma%20PD/#video-del-funcionamiento-final","title":"Video del Funcionamiento Final","text":"<p>\ud83c\udfa5 https://www.youtube.com/watch?v=ID_DEL_VIDEO](https://www.youtube.com/watch?v=zepItAOh-Lk \ud83c\udfa5 https://www.youtube.com/watch?v=MQ0QVBZc3m0</p>"},{"location":"Plataforma%20PD/#9-conclusiones","title":"9) Conclusiones","text":"<ul> <li>Fue necesario trabajar con ganancias PD diferenciadas seg\u00fan el comportamiento observado (mayor proporcionalidad para mejorar el tiempo de respuesta).</li> <li>Se determin\u00f3 que ampliar la distancia f\u00edsica entre los servos permiti\u00f3 mayor precisi\u00f3n en la inclinaci\u00f3n y favoreci\u00f3 el control de la pelota.</li> <li>Se identific\u00f3 la importancia de optimizar la velocidad de respuesta de los servomotores, ya que influy\u00f3 directamente en la estabilidad de la plataforma.</li> <li>La estructura de control basada en visi\u00f3n y retroalimentaci\u00f3n demostr\u00f3 ser viable para aplicaciones din\u00e1micas de estabilizaci\u00f3n en tiempo real.</li> </ul>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"recursos/PR%C3%81CTICA%203/","title":"\ud83d\udcda Pr\u00e1ctica 1: Comunicaci\u00f3n Serial con ESP32-C6 en Arduino","text":""},{"location":"recursos/PR%C3%81CTICA%203/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Karen N\u00e1jera y Arith Maldonado </li> <li>Curso / Asignatura: Elementos programables II </li> <li>Fecha: 18/09/2025 </li> <li>Descripci\u00f3n breve:   En esta pr\u00e1ctica se implement\u00f3 un c\u00f3digo en Arduino IDE para establecer comunicaci\u00f3n serial con un ESP32-C6. Se explic\u00f3 el funcionamiento de los diferentes tipos de variables (<code>int</code>, <code>char</code>, <code>string</code>, <code>float</code>, <code>bool</code>) y la cantidad de datos que puede almacenar cada uno. Adem\u00e1s, se analizaron las diferencias entre los dos puertos de comunicaci\u00f3n del ESP32 (UART y USB nativo) y c\u00f3mo este recibe mensajes enviados desde el monitor serial.</li> </ul>"},{"location":"recursos/PR%C3%81CTICA%203/#2-objetivos","title":"2) Objetivos","text":"<ul> <li> <p>General: Comprender el funcionamiento b\u00e1sico de la comunicaci\u00f3n serial en el ESP32-C6 usando Arduino IDE. </p> </li> <li> <p>Espec\u00edficos: </p> </li> <li>Identificar y diferenciar los principales tipos de variables en Arduino.  </li> <li>Implementar un programa que permita recibir y mostrar mensajes en el monitor serial.  </li> <li>Analizar la diferencia entre el puerto UART (serial cl\u00e1sico) y el puerto USB nativo del ESP32.  </li> <li>Verificar la correcta recepci\u00f3n y env\u00edo de caracteres mediante pruebas pr\u00e1cticas.  </li> </ul>"},{"location":"recursos/PR%C3%81CTICA%203/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: </li> <li>Uso del ESP32-C6 como dispositivo de comunicaci\u00f3n serial.  </li> <li>Configuraci\u00f3n del baud rate en el monitor serial.  </li> <li>Recepci\u00f3n y env\u00edo de mensajes en el IDE de Arduino.  </li> <li> <p>Explicaci\u00f3n te\u00f3rica de los tipos de variables y su uso en la pr\u00e1ctica.  </p> </li> <li> <p>No incluye: </p> </li> <li>Conexi\u00f3n a sensores externos.  </li> <li>Programaci\u00f3n de librer\u00edas adicionales.  </li> <li>Uso de comunicaci\u00f3n inal\u00e1mbrica (Wi-Fi / Bluetooth).  </li> </ul>"},{"location":"recursos/PR%C3%81CTICA%203/#4-resultados","title":"4) Resultados","text":"<p>Durante la pr\u00e1ctica se logr\u00f3:  </p> <ul> <li>Recepci\u00f3n de datos seriales: El ESP32-C6 recibi\u00f3 correctamente mensajes enviados desde el monitor serial, aunque en un inicio aparecieron caracteres extra\u00f1os debido a un baud rate incorrecto. Ajustando la velocidad a 38400 baudios se solucion\u00f3 el problema.  </li> <li>Tipos de datos: </li> <li><code>int</code> \u2192 n\u00fameros enteros (16 bits).  </li> <li><code>char</code> \u2192 un car\u00e1cter (1 byte).  </li> <li><code>string</code> \u2192 cadena de caracteres (m\u00ednimo 16 bits, m\u00e1ximo variable).  </li> <li><code>float</code> \u2192 n\u00fameros con decimales (32 bits).  </li> <li><code>bool</code> \u2192 valores l\u00f3gicos (1 bit).  </li> <li>Puertos de comunicaci\u00f3n: </li> <li>UART (Universal Asynchronous Receiver-Transmitter): puerto serial tradicional, \u00fatil para depuraci\u00f3n o conexi\u00f3n con otros dispositivos.  </li> <li>USB nativo: permite programar directamente el microcontrolador y tambi\u00e9n enviar datos sin necesidad de un conversor externo.  </li> </ul> <p>C\u00f3digo Implementado</p> <p>```cpp char msg;</p> <p>void setup() {   Serial.begin(38400);   // Inicializa comunicaci\u00f3n serial }</p> <p>void loop() {   if (Serial.available()) {   // Verifica si hay datos     msg = Serial.read();      // Lee el car\u00e1cter     Serial.print(msg);        // Lo reenv\u00eda al monitor   } }</p>"}]}